[{"title":"python进阶","path":"2022/06/13/python进阶/","text":"PYTHON进阶生成式（推导式）的用法prices = &#123; &#39;AAPL&#39;: 191.88, &#39;GOOG&#39;: 1186.96, &#39;IBM&#39;: 149.24, &#39;ORCL&#39;: 48.44, &#39;ACN&#39;: 166.89, &#39;FB&#39;: 208.09, &#39;SYMC&#39;: 21.29 &#125; # 用股票价格大于100元的股票构造一个新的字典 prices2 = &#123;key: value for key, value in prices.items() if value &gt; 100&#125; #key:value for key 字典遍历 print(prices2) 嵌套的列表的坑names = [&#39;关羽&#39;, &#39;张飞&#39;, &#39;赵云&#39;, &#39;马超&#39;, &#39;黄忠&#39;] courses = [&#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;] # 录入五个学生三门课程的成绩 scores = [[None] * len(courses) for _ in range(len(names))] #enumerate 是列表索引 for row, name in enumerate(names): for col, course in enumerate(courses): scores[row][col] = float(input(f&#39;请输入&#123;name&#125;的&#123;course&#125;成绩: &#39;)) print(scores) heapq模块（堆排序）&quot;&quot;&quot; 从列表中找出最大的或最小的N个元素 堆结构(大根堆/小根堆) &quot;&quot;&quot; import heapq list1 = [34, 25, 12, 99, 87, 63, 58, 78, 88, 92] list2 = [ &#123;&#39;name&#39;: &#39;IBM&#39;, &#39;shares&#39;: 100, &#39;price&#39;: 91.1&#125;, &#123;&#39;name&#39;: &#39;AAPL&#39;, &#39;shares&#39;: 50, &#39;price&#39;: 543.22&#125;, &#123;&#39;name&#39;: &#39;FB&#39;, &#39;shares&#39;: 200, &#39;price&#39;: 21.09&#125;, &#123;&#39;name&#39;: &#39;HPQ&#39;, &#39;shares&#39;: 35, &#39;price&#39;: 31.75&#125;, &#123;&#39;name&#39;: &#39;YHOO&#39;, &#39;shares&#39;: 45, &#39;price&#39;: 16.35&#125;, &#123;&#39;name&#39;: &#39;ACME&#39;, &#39;shares&#39;: 75, &#39;price&#39;: 115.65&#125; ] print(heapq.nlargest(3, list1)) print(heapq.nsmallest(3, list1)) print(heapq.nlargest(2, list2, key=lambda x: x[&#39;price&#39;])) print(heapq.nlargest(2, list2, key=lambda x: x[&#39;shares&#39;])) #key = lambda x:x[0] 寻找该元素中的值 #max(num,key=lambda x:x[1])寻找位置2的元素最大值 itertools模块&quot;&quot;&quot; 迭代工具模块 &quot;&quot;&quot; import itertools # 产生ABCD的全排列 itertools.permutations(&#39;ABCD&#39;) # 产生ABCDE的五选三组合 itertools.combinations(&#39;ABCDE&#39;, 3) # 产生ABCD和123的笛卡尔积 itertools.product(&#39;ABCD&#39;, &#39;123&#39;) # 产生ABC的无限循环序列 itertools.cycle((&#39;A&#39;, &#39;B&#39;, &#39;C&#39;)) itertools模块&quot;&quot;&quot; 迭代工具模块 &quot;&quot;&quot; import itertools # 产生ABCD的全排列 itertools.permutations(&#39;ABCD&#39;) # 产生ABCDE的五选三组合 itertools.combinations(&#39;ABCDE&#39;, 3) # 产生ABCD和123的笛卡尔积 itertools.product(&#39;ABCD&#39;, &#39;123&#39;) # 产生ABC的无限循环序列 itertools.cycle((&#39;A&#39;, &#39;B&#39;, &#39;C&#39;)) for item in itertools.permutations(&#39;ABCD&#39;): print(item) #类似生成排列组合 collections模块&quot;&quot;&quot; 找出序列中出现次数最多的元素 &quot;&quot;&quot; from collections import Counter words = [ &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;, &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;not&#39;, &#39;around&#39;, &#39;the&#39;, &#39;eyes&#39;, &quot;don&#39;t&quot;, &#39;look&#39;, &#39;around&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;, &quot;you&#39;re&quot;, &#39;under&#39; ] counter = Counter(words) print(counter.most_common(3)) 数据结构和算法排序算法（选择、冒泡）和查找算法（顺序和折半）#选择排序 import sys A = [64, 25, 12, 22, 11] for i in range(len(A)): min_idx = i for j in range(i + 1, len(A)): if A[min_idx] &gt; A[j]: min_idx = j A[i], A[min_idx] = A[min_idx], A[i] #两个互换位置 print(&quot;排序后的数组：&quot;) for i in range(len(A)): print(&quot;%d&quot; % A[i]) #冒泡排序 def bubbleSort(arr): n = len(arr) # 遍历所有数组元素 for i in range(n): # Last i elements are already in place for j in range(0, n - i - 1): if arr[j] &gt; arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] arr = [64, 34, 25, 12, 22, 11, 90] bubbleSort(arr) print(&quot;排序后的数组:&quot;) for i in range(len(arr)): print(&quot;%d&quot; % arr[i]) def seq_search(items, key): &quot;&quot;&quot;顺序查找&quot;&quot;&quot; for index, item in enumerate(items): if item == key: return index return -1 items=[1,45533,344,2131] print(seq_search(items,344)) #感觉只适合奇数 def bin_search(items, key): &quot;&quot;&quot;折半查找&quot;&quot;&quot; start, end = 0, len(items) - 1 while start &lt;= end: mid = (start + end) // 2 if key &gt; items[mid]: start = mid + 1 elif key &lt; items[mid]: end = mid - 1 else: return mid return -1 items=[1,45533,22,344,2131] print(bin_search(items,344)) 常用算法： 穷举法 - 又称为暴力破解法，对所有的可能性进行验证，直到找到正确答案。 贪婪法 - 在对问题求解时，总是做出在当前看来最好的选择，不追求最优解，快速找到满意解。 分治法 - 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到可以直接求解的程度，最后将子问题的解进行合并得到原问题的解。 回溯法 - 回溯法又称为试探法，按选优条件向前搜索，当搜索到某一步发现原先选择并不优或达不到目标时，就退回一步重新选择。 动态规划 - 基本思想也是将待求解问题分解成若干个子问题，先求解并保存这些子问题的解，避免产生大量的重复运算。 #穷举法例子：百钱百鸡和五人分鱼。 # 公鸡5元一只 母鸡3元一只 小鸡1元三只 # 用100元买100只鸡 问公鸡/母鸡/小鸡各多少只 for x in range(20): for y in range(33): z = 100 - x - y if 5 * x + 3 * y + z // 3 == 100 and z % 3 == 0: print(x, y, z) 面向对象相关知识三大支柱：封装、继承、多态 例子：工资结算系统。 &quot;&quot;&quot; 月薪结算系统 - 部门经理每月15000 程序员每小时200 销售员1800底薪加销售额5%提成 &quot;&quot;&quot; from abc import ABCMeta, abstractmethod class Employee(metaclass=ABCMeta): &quot;&quot;&quot;员工(抽象类)&quot;&quot;&quot; def __init__(self, name): self.name = name @abstractmethod def get_salary(self): &quot;&quot;&quot;结算月薪(抽象方法)&quot;&quot;&quot; pass class Manager(Employee): &quot;&quot;&quot;部门经理&quot;&quot;&quot; def get_salary(self): return 15000.0 class Programmer(Employee): &quot;&quot;&quot;程序员&quot;&quot;&quot; def __init__(self, name, working_hour=0): self.working_hour = working_hour super().__init__(name) def get_salary(self): return 200.0 * self.working_hour class Salesman(Employee): &quot;&quot;&quot;销售员&quot;&quot;&quot; def __init__(self, name, sales=0.0): self.sales = sales super().__init__(name) def get_salary(self): return 1800.0 + self.sales * 0.05 class EmployeeFactory: &quot;&quot;&quot;创建员工的工厂（工厂模式 - 通过工厂实现对象使用者和对象之间的解耦合）&quot;&quot;&quot; @staticmethod def create(emp_type, *args, **kwargs): &quot;&quot;&quot;创建员工&quot;&quot;&quot; all_emp_types = &#123;&#39;M&#39;: Manager, &#39;P&#39;: Programmer, &#39;S&#39;: Salesman&#125; cls = all_emp_types[emp_type.upper()] return cls(*args, **kwargs) if cls else None def main(): &quot;&quot;&quot;主函数&quot;&quot;&quot; emps = [ EmployeeFactory.create(&#39;M&#39;, &#39;曹操&#39;), EmployeeFactory.create(&#39;P&#39;, &#39;荀彧&#39;, 120), EmployeeFactory.create(&#39;P&#39;, &#39;郭嘉&#39;, 85), EmployeeFactory.create(&#39;S&#39;, &#39;典韦&#39;, 123000), ] for emp in emps: print(f&#39;&#123;emp.name&#125;: &#123;emp.get_salary():.2f&#125;元&#39;) if __name__ == &#39;__main__&#39;: main()"},{"title":"python基础","path":"2022/06/03/python基础/","text":"python基础PYTHON代码书写格式 def main(): # Todo: Add your code here pass if __name__ == &#39;__main__&#39;: main() 实现计算求最大公约数和最小公倍数的函数def common(a,b): while b: c=a%b a=b b=c pass return a def beishu(a,b,c): d=a*b/c return d a=453 b=36 c=common(a,b) d=beishu(a,b,c) print(c) print(d) 实现判断一个数是不是回文数的函数def huiwen(b): c=str(b) h=len(c) d=0 for num in range(h): d=d*10+b%10 b=b//10 pass return d b=1221 d=huiwen(b) if d==b: print(&quot;这个是回文&quot;) pass 在屏幕上显示跑马灯文字import os import time def main(): content=&quot;北京欢迎你........&quot; while True: #清空屏幕输出 #os.system(&quot;cls&quot;) print(content) #休眠200毫秒 time.sleep(1) content=content[1:]+content[0] pass pass if __name__ ==&quot;__main__&quot;: main() 设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成import random def generate_code(code_len=4): all_chars=&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; last_pos= len(all_chars)-1 code=&#39;&#39; for _ in range(code_len): index = random.randint(0,last_pos) code=code+all_chars[index] return code print(generate_code()) 计算指定的年月日是这一年的第几天def is_leap_year(year): &quot;&quot;&quot; 判断是否为闰年 是闰年返回True 否则返回Flase &quot;&quot;&quot; return year%4==0 and year%100!=0 or year%400==0 def which_day(year,month,day): days_of_month = [ [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] ][is_leap_year(year)] total=0 for index in range(month-1): total =total+days_of_month[index] return total+day def main(): print(which_day(1980, 11, 28)) if __name__ == &#39;__main__&#39;: main() 创建和使用对象class Student(object): # __init__是一个特殊方法用于在创建对象时进行初始化操作 # 通过这个方法我们可以为学生对象绑定name和age两个属性 def __init__(self, name, age): self.name = name self.age = age def study(self, course_name): print(&#39;%s正在学习%s.&#39; % (self.name, course_name)) # PEP 8要求标识符的名字用全小写多个单词用下划线连接 # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识) def watch_movie(self): if self.age &lt; 18: print(&#39;%s只能观看《熊出没》.&#39; % self.name) else: print(&#39;%s正在观看岛国爱情大电影.&#39; % self.name) def main(): # 创建学生对象并指定姓名和年龄 stu1 = Student(&#39;骆昊&#39;, 38) # 给对象发study消息 stu1.study(&#39;Python程序设计&#39;) # 给对象发watch_av消息 stu1.watch_movie() stu2 = Student(&#39;王大锤&#39;, 15) stu2.study(&#39;思想品德&#39;) stu2.watch_movie() if __name__ == &#39;__main__&#39;: main() 定义一个类描述数字时钟import time class Clock(object): &quot;&quot;&quot;数字时钟&quot;&quot;&quot; def __init__(self,hour=0,minute=0,second=0): self._hour = hour self._minute = minute self._second = second def run(self): &quot;&quot;&quot;走字&quot;&quot;&quot; self._second+=1 if self._second==60: self._minute+=1 self._second=0 if self._minute==60: self._minute=0 self._hour+=1 if self._hour==24: self._hour=0 def show(self): &quot;&quot;&quot;显示时间&quot;&quot;&quot; return &quot;%02d:%02d:%02d&quot;% (self._hour,self._minute,self._second) def main(): clock = Clock(23, 59, 58) while True: print(clock.show()) time.sleep(1) clock.run() if __name__ == &#39;__main__&#39;: main() 读写文本文件&#39;&#39;&#39; 在含有转义符的字符串前加‘r’表示字符串内按原始含义解释，不做转义处理。 &#39;&#39;&#39; def main(): f = open(r&#39;D:\\UIDQ4214\\Desktop\\123.txt&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;) print(f.read()) f.close() if __name__ == &#39;__main__&#39;: main() 异常处理&#39;&#39;&#39; 为了让代码有一定的健壮性和容错性，我们可以使用Python的异常机制对可能在运行时发生状况的代码进行适当的处理 &#39;&#39;&#39; def main(): f = None try: f = open(&#39;致橡树.txt&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;) print(f.read()) except FileNotFoundError: print(&#39;无法打开指定的文件!&#39;) except LookupError: print(&#39;指定了未知的编码!&#39;) except UnicodeDecodeError: print(&#39;读取文件时解码错误!&#39;) finally: if f: f.close() if __name__ == &#39;__main__&#39;: main() 验证输入用户名和QQ号是否有效并给出对应的提示信息&quot;&quot;&quot; 验证输入用户名和QQ号是否有效并给出对应的提示信息 要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间，QQ号是8~13的数字且首位不能为0 &quot;&quot;&quot; import re def main(): username = input(&quot;请输入用户名:&quot;) qq = input(&quot;请输入qq号：&quot;) # match函数的第一个参数是正则表达式字符串或正则表达式对象 # 第二个参数是要跟正则表达式做匹配的字符串对象 m1 = re.match(r&#39;^[0-9a-zA-Z_]&#123;6,20&#125;$&#39;, username) if not m1: print(&quot;请输入有效的用户名&quot;) pass m2=re.match(r&#39;^[1-9]\\d&#123;8,13&#125;$&#39;,qq) if not m2: print(&quot;请输入有效的QQ号&quot;) if m1 and m2: print(&quot;输入信息有效&quot;) if __name__ == &#39;__main__&#39;: main() 从一段文字中提取出国内手机号码import re def main(): # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字 pattern = re.compile(r&#39;(?&lt;=\\D)1[34578]\\d&#123;9&#125;(?=\\D)&#39;) sentence = &#39;&#39;&#39; 重要的事情说8130123456789遍，我的手机号是13512346789这个靓号， 不是15600998765，也是110或119，王大锤的手机号才是15600998765。 &#39;&#39;&#39; # 查找所有匹配并保存到一个列表中 mylist = re.findall(pattern, sentence) print(mylist) print(&#39;--------华丽的分隔线--------&#39;) # 通过迭代器取出匹配对象并获得匹配的内容 for temp in pattern.finditer(sentence): print(temp.group()) print(&#39;--------华丽的分隔线--------&#39;) # 通过search函数指定搜索位置找出所有匹配 m = pattern.search(sentence) while m: print(m.group()) m = pattern.search(sentence, m.end()) if __name__ == &#39;__main__&#39;: main() 替换字符串中的不良内容import re def main(): sentence = &#39;你丫是傻叉吗? 我操你大爷的. Fuck you.&#39; purified = re.sub(&#39;[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔&#39;, &#39;*&#39;, sentence, flags=re.IGNORECASE) print(purified) # 你丫是*吗? 我*你大爷的. * you. if __name__ == &#39;__main__&#39;: main() 拆分长字符串import re def main(): poem = &#39;窗前明月光，疑是地上霜。举头望明月，低头思故乡。&#39; sentence_list = re.split(r&#39;[，。, .]&#39;, poem) while &#39;&#39; in sentence_list: sentence_list.remove(&#39;&#39;) print(sentence_list) # [&#39;窗前明月光&#39;, &#39;疑是地上霜&#39;, &#39;举头望明月&#39;, &#39;低头思故乡&#39;] if __name__ == &#39;__main__&#39;: main()"},{"title":"GIT","path":"2022/06/01/GIT/","text":"GItGit软件配置通过ssh 的方式来访问服务器，和提交代码到服务器。ssh 是基于网络的完全传输协议,需要配置一下ssh 公钥，用来做每次访问的自动认证，也帮我们省去每次访问输入密码的步骤 打开Git Bash 输入命令：mkdir ~/.ssh， 创建~/.ssh 目录 进入到~/.ssh 目录下:cd ~/.ssh 输入指令:ssh-keygen.eve（命令按Tab可以补全），生成ssh 公钥 一路回车；中间会请求输入密码，直接按回车（不要输入密码），会生成2个文件 输入命令cat id_rsa.pub，会显示该文件内容；选择显示的内容，点击右键，就已经把内容复制到粘贴 7.登陆后， 填入生产的共钥和个人邮箱"},{"title":"四季不过春夏，四年不明秋冬","path":"2022/05/21/四季不过春夏，四年不明秋冬/","text":"四季不过春夏，四年不明秋冬 四年，如果往回看便会感觉时光飞逝，光阴难求；但如果有着自己喜怒哀乐所加持，那便是赋予了时间另一重意义了。而这四年匆匆有着属于我自己的意义。我本是南方一个小县城里一个小镇做题家，因一场高考而踏出自己小天地到一个名为大学的地方求学明理，而今路已到拐角之处，回眸脚下斑斑印记，也有一些可所追忆的吧，毕竟每一个鞋印的深浅都挑动着我的思绪。 关于学业​ 自从作为一名学生以来，一切的喜怒哀乐都是与学习相关，甚至于到了大学这个阶段，仍然占了较为大的份额，然而纵观我迄今为止的学习生涯来看都是处于比上不足比下有余的状态，不能说从未有过巅峰，只能说偶尔有点小起潮吧。或许从未有过成功，我倒是对很多事情都比较淡然，做啥事都是能用就行的心态，从来不会苛责自己去做到百分百，万事能有个及格就行，而这也贯穿了我整个大学的学习生涯。卷面成绩不行，那总得去搞点别的事情充实自己生活吧，因此我的四年算是一直处于三分钟热度的状态，做啥事都不上心和不上进——或许可以换句话来说，我对万事万物都好奇，都想接触一下，并且了解其中一些浅在的规则。在这四年内，我参加了传媒部门，了解了一些公众号推送的制作流程；我参加了青年志愿者协会，了解幕后志愿时长是如何给予的；我参加了计算机协会，了解了一台电脑遇到一些比较浅显的问题是如何解决的，电脑重装和电脑拆卸等相关；我还参加了各类各样的科技比赛，了解了一些电子产品是如何操控和DIY的。没错，仅限于了解，每一个事情我都没有很深入的去了解其内在逻辑和满怀热爱去完成。但如果说有一件事情是我一直以来都去做的，那便是兼职。 关于兼职​ 在这四年之间，我做过不少兼职。有去一个小学作为裁判员帮小学生完成赛车比赛，看着小学生完成自己的赛车组装和运行——这或许是大城市才有的课余活动吧；有作为一个羽毛球比赛的司线员，判断线是否出界——属于是带薪看喜欢运动的比赛了；有去税务局帮忙记录档案和处理档案，一份份档案过档记录机械式的工作与看着身旁的阿姨休闲得饮茶——一个月干下来也没几个钱，倒是认识了两位有意思的朋友；还有每年寒暑假都会做的家教兼职，这个就是我大学以来一直坚持去做的事，无他只因轻松和赚的比较多。也没细算过我做家教兼职教过多少个学生了，我猜应该至少有高中一个班这么多了吧。家教兼职算是比较有意思的了，你会看到各式各样不一样的人为着自己的当初心愿努力着，无论基础高低，他们各自有梦，也各自奋斗，而作为一个兼职老师，我在其中也只是承担了答疑和解惑的角色吧。我也不清楚他们最后都到了哪，人生有着怎样的精彩，但是这份兼职我感觉也算无愧于心，也希望他们到下一个阶段，快快乐乐地生活吧。 关于友情​ 大学期间也遇到了各自发光的朋友吧，有在青协遇到的两个善良的师姐，每次需要啥抱佛脚的资料第一时间都会想到她们两，她们也会很耐心和热心的帮忙；有在传媒中遇到的三个师兄，他们无论何时都会去营造传媒一家亲的氛围，并且在每个节假日都会搞事，和他们待一块真的有那种挚友的感觉；有在计协认识的各位，每次遇到啥事都习惯在计协群里吐槽和咨询，并且大家伙偶尔聚聚餐也挺好的，哈哈；有在同乡会认识的亲们，让我在远在他乡也能有所寄托；有共宿四年的舍友，虽然我感觉每个舍友都有着自己的交际圈，平时很少交流，但是他们每个人都会照顾我好多，特别是东哥，每次都会带点小零食回宿舍分食并且在考研那段日子都会提醒摆烂的我；有两个一直互帮互助的潮汕朋友；有隔壁三位周周带我出去开荤；也有一位一直为我们着想的良师（可惜大三才认识）；还有一起入读这所大学的高中同学………………我一直以为自己这四年的交际圈应该是封闭的，今晚细想，貌似我真的很幸运耶。 关于未来​ 上大学前，认为这四年将会是学海的最后一站了吧，毕竟读书真的在精神上太苦了——我觉得“迷茫”二字真的充斥着着整个四年，不晓得明天该往哪去，不晓得未来自己能做什么，也不晓得自己所学到底有啥意义，只能过一天算一天的感觉。也正因为不晓得自己未来能从事什么方向，所以在大三那一年也算是逃避就业选择了考研，之后便是一整年的备考生涯了。在备考的过程中，有没有什么波浪起伏，有得只是平平淡淡得准备着今天做啥明天做啥，那时候也不晓得自己能不能考得上，总想着反正没事干，便慢慢学呗，反正一直以来的生活都是平平无奇。在考完的那天，和研友一起吃了顿饭，回宿舍清理了书籍就急匆匆得出去实习了。实习总得来说算是打碎自己以往所学，从新建立知识体系的过程吧，这过程还是比较痛苦的，当时认为自己考不上没退路了，那段时间还算比较努力，也成功拿了offer，薪资也能接受，一连过去三个月，到了初试公布成绩的那一刻了，发现自己貌似能考上，随之而来的便是恐惧和迷茫。人真的一旦有了选择，便会犹豫和畏缩，那段时间，我真的整天晚上都在思考读研会怎么样和工作会怎么样，晚晚睡眠质量都很差，最后实在挺不住了便索性回家先准备复试，真正有得选再说，而后的结局便如现在这般吧，继续接受着“迷茫‘与”渺小“用后悔三年来换未来可能会后悔一辈子的可能性吧。 ​ 以上便是来者四年自述。"},{"title":"2022-5-近况闲谈","path":"2022/05/15/2022-5-近况闲谈/","text":"呼~总算稍微有点空闲，自我思考的时间了，这几天被裹挟着每天都忙忙碌碌，而且最近起床的时间点貌似是在七点多了，我不知道为啥。 首先是五一假期吧，那时候先回家见见阿婆，然后相互之间吹吹水。看到老人家身体较好，也就没啥事了，那天晚上还去了一个阿伯家里吃饭。五一假期结束后，就乘坐顺风车返校准备毕业论文答辩了。在等待的过程中，被隔壁宿舍拉去了吃了好几顿饭。本科答辩吧，讲真答辩前很紧张，感觉可能不过，但自己又摆烂，不想努力，最后虽然被喷得狗血淋头，但也算过去了。答辩完，就需要准备一些材料，准备完后就去江湾那边和康南拍毕业照了。 毕业照这种东西，我倒是不看重，有时候会感觉是自己人生结尾的见证，不拍有点可惜，但有时候又感觉自己没在佛大留下任何回忆和过去，悄然离去也好吧~所以我在17号的时候就跑来公司继续打工，加油，打工人！！！！ 下面放一些自己的拍的吧………. emm，回来继续打工貌似全组人都知道读研的事情，有些许尴尬，不过自己菜也没办法，只能先继续干着了~~"},{"title":"近况闲谈_2022_3/4","path":"2022/04/07/近况闲谈-2022-3/","text":"​ 如果说二月是收获的一月，那三月就是迷茫的一月了。 我遇到了人生之中较为困难的抉择，到底是继续往上读还是安于现状打工呢？这个问题让我每晚一想就彻夜难眠。每天也不知道在干吗………迷茫，一直在想向上读工资待遇也是这样子，如果继续工作的话，人生貌似按下暂停键了 ​ 终于在一个实习时候接到的SOMEIP的任务中由于加班过狠，就辞掉实习了！先回家慢慢思考 回到家后，浑浑噩噩得复习了一个礼拜多吧，具体的知识点已经不想在回顾了，就通知复试了~ 提交好复试相关的资料，就准备复试了 当然，现在写的这篇文主要也是为了记录一下复试的过程。 一开始是让我选择专业课的号码，我抽了第八题 第一道题较为简单，是说数字通信系统的组成和优缺点 第二道是说升余弦滚降波形的特征和优缺点 第三道题是说什么滤波器的特性和优缺点（第三道题真的没见过） 之后就是英语面试了。第一个是30s，用英语介绍一下自己 第二个是一分半，用英语介绍自己最好的朋友（我英语烂到鬼嗨，又不想说——也怪我没练习过，难受） 后面就是看我成绩单，问了微波天线，这个才是我最绝望的，那门课都是老师水过来的，我都没见过，我真的一点都不会啊！！！！！ 之后就看我简历来问了，简历上的东西貌似有个我自己也不理解，算了，也算勉勉强强的回答了。 后面就问我志愿服务方面的，这个是我的疏忽，我以为研究生面试不讲志愿服务的，谁知道有老师看……. 而后和我讲了一下联培吧~问我有没有想法，我就记得当时回答了是吧…. 无所谓了，真的感觉一直在等他通知，很难受，自己也没好好重视这个复试，一年以来也就这样子吧~~ 最后还是选择了读研 四月应该是比较平淡的一月，无啥事发生，就是一开始毕设有点翻车"},{"title":"SOME_IP","path":"2022/03/25/SOME-IP/","text":"SOME ipSOME/IP (Scalable service-Oriented MiddlewarE over IP) 是车载以太网通信引入的一个概念，位于OSI 7层模型的层4之上。在以CAN总线为主的车载网络中，通信过程是面向信号的（除了诊断通信之外），这是一种根据发送者需求实现的通信过程，当发送者发现信号的值变化了，或者发送周期到了，就会发送信息，而不考虑接收者是否有需求。而SOME/IP则不同，它是在接收方有需求的时候才发送，这种方法的优点在于总线上不会出现过多不必要的数据，从而降低负载。 在车载网络中，某个ECU有时会需要调用实现在其他ECU上的个服务，这个时候它俩就分别扮演了client和server的角色，而SOME/IP就是实现这种远程服务调用的接口 导入数据类型 混合数据类型 具体步骤"},{"title":"Autosar_CAN_config","path":"2022/03/05/Autosar-CAN-config/","text":"Autosar导入一路can配置 can通道是从can传到candr再到canif 再到canpdu再到com再到rte 看图可知 导入一路CAN_DBC_1 导入一路CAN_DBC_2"},{"title":"干扰器 Busoff_VH6501","path":"2022/02/24/干扰器-Busoff-VH6501/","text":"干扰器 Busoff_VH65011.同步对采样点的影响 ​ 由于不同ECU的时钟振荡频率误差、信号传输延时等原因，各节点的接收器需要进行同步，以消除这类误差对信号采样带来的影响。在帧起始SOF，进行一次硬同步。当后续由隐性到显性的跳边沿没有落在同步段，且误差大于同步跳转宽度SJW时，根据相位误差e的正负情况，选择增长PBS1或者缩短PBS2，以移动采样点的位置，确保采样值具有更高的可靠性) 1.2采样点测试原理根据位定时概念及采样点定义，我们可以利用CAN干扰仪，对ECU发出的某条报文，按Tq进行干扰。当ECU识别到信号被干扰时，即会发送错误帧并重新发送该报文。ECU识别到错误的时候，即是干扰电平被ECU采样点采集到的时候，此时就可以通过干扰的Tq数量计算出ECU的采样点位置。如下图，右起干扰4个Tq时，总线报错，而ECU位时间Tq总数为10，所以采样点位置为 (10-4)/10*100%=60% 。 执行测试： 执行脚本，通过多次设置脚本中n的值来更改干扰序列，当Trace中出现100%的错误帧时，记录当前n的值，计算采样点为**(10-n)/10*100%**。 可设置比例，ACKSLOT固定总比是320，通过收发的比例可知道采样点的位置。 2. Busoff恢复时间测试原理为了测试Busoff恢复时间，需要使ECU节点进入Busoff状态，即使用干扰仪，对ECU发出的某条报文进行干扰。由于每次干扰发送，ECU的发送错误计数器TEC加8，报文被干扰后，ECU会进行重发。即我们需要对ECU的报文连续干扰256/8=32次，让ECU进入Busoff状态。 当ECU从Busoff恢复之后，会尝试继续发送之前的报文，所以我们可以直接对ECU报文干扰32+1次，前32次使其进入Busoff，第33次干扰的是ECU Busoff恢复后尝试重发的第一帧报文，即最后两帧错误帧之间的时间间隔就是Busoff恢复时间。 执行测试： 执行脚本，从Trace中查看第33帧错误帧的时间间隔，即为Busoff恢复时间。 3. VH6501干扰仪使用1.1 Disturbance Sample使用 PC端必须安装Vector CANoe11.0版本，打开CANoe，以下路径加载Sample：“File”——“SampleConfiguration”—— “CAN-Additional”——“Disturbance”。 最好找到Sample所在的路径，将Sample相关的配置工程Copy出来再打开，不要直接在原Sample配置进行文件的修改。 打开Sample之后，“Home”菜单依次选择“Panel”——“MainConfigPanel”。 在MainConfigPanel界面，“Repetition-Configuration”中输入 点击“Trigger Configuration”按钮打开Trigger配置面板，进行Trigger配置 在TriggerConfigurationPanel界面： i. 在“CurrTriggerField”中选择干扰位置； ii. 在“IDBase”中输入所需要干扰的报文ID，注意需要输入11个位。（由报文ID转二进制） iii. 普通CAN报文选择AckSlot，CANFD选ID Base 返回MainConfigPanel，点击“Sequence Configuration”按钮，打开序列配置面板，进行干扰序列配置。 在SequencePanel界面： i. 设置干扰序列的干扰值： l 选择“Dominant”，强制干扰为显性； l 选择“Recessive”，干扰为隐性，隐性位不受干扰，即不对总线进行干扰； l 选择“RecessiveStress”，强制干扰为隐性。 ii. 设定干扰序列的长度： l 选择“Arbitration Bit Timing Information”则写入320ticks的干扰序列长度，即2us(可用于CAN Busoff恢复时间测试)； l 选择“Data Bit Timing Information”则写入40ticks的干扰序列，即250ns(用于CAN FD数据场的干扰)； l 选择“Sequence Segment Control”需要自己定义干扰序列长度，1ticks代表6.25ns，此项可用于采样点测试。举例，如测试500k速率(位时间为2us，相当于320ticks)，采样点75%的ECU，对ACK界定符进行干扰。此时，可以写入32075%=240ticks的“Recessive”序列，再写入32025%=80ticks的“Dominant”序列，就会产生错误帧。 iii. 点击“Add Segment”即可添加所需的干扰序列，如需要重新配置序列，需先点击“Clear Sequence”，清除干扰序列。 总长度是320 在Dominant下面的第三个按钮（User Definded Ticks）是可以选择比例的，选222的话，那采样点就是222/320了 配置完Trigger和Sequence之后，返回MainConfigPanel，点击“Enable On Device”即可执行干扰。"},{"title":"近况闲谈_2022_2","path":"2022/02/15/2022-2-近况闲谈/","text":"也不知道是不是因为在十字路口上的不确定性，过年连打扑克牌的欢喜都没了，也不敢想太多，怕睡不着觉~人啊，说好摆烂也不敢摆，怕停下来，就会一直停滞了。 今年过年格外寒冷，一直下雨，在老家除了躺尸也不知道干啥好，时间感觉过得既快又慢，体重倒是涨了很多。 二月八号我就跑来工厂这边了，当天晚上还被门卫拦着了，只能先回阿姨那边了。难受，明明有时候不是自己的锅，但还是得自己受着，当时行政通知是可以进宿舍区的，不过算了~ 回到工位还是没啥任务，也就日常看看文档，然后瞎折腾一下吧，也没计划，算了，等等21号吧。 二月十四号，出去跟李昊卖花了，倒是那时候看着也有点意思，遇到一位逛了三次还是咬牙买下花的男孩，遇到一对手语人夫妇在彼此交流，还遇到很多对着自己的那份欢喜下单的有情人~ 二月十五号，今天刚发工资了，1.5K，嗯，也就这样子吧，无所谓了，反正在学校待着也是待着。 二月二十一号，不出意料的出考研成绩了，哎，拼命争取的选择权，又一次让我头疼不已，嗯，也是这天，我貌似知道本科应届的薪资还是我能够接受的，也不知道未来如何~前进的双岔路口又摆在我跟前。 二月二十四号，今天出四六级成绩，总算总算考过了四级，虽然有点丢人，但真的考了三年了~ 拿到offer了,二月的事情应该就过去了吧"},{"title":"关于被抓去产线支援两天个人想法","path":"2022/01/26/关于被抓去产线支援两天个人想法/","text":"如标题所示，就是被抓去产线支援了，不知道从何说起，还是按照时间线吧…… 周末领导一通电话，让我们去产线，当时还没反应过来是干什么，后面才想到一直站着，那不就是流水线嘛？所以就这般，我就进去了流水线。 我曾经以为我这辈子都不可能进流水线的，因为听说过它的重复性和麻木性，所以一直比较抗拒它，不过既然是领导安排，那也没办法了，毕竟也就那么两天回去过年了，总不至于就为了两天就提桶吧。 在上午，就是等待领静电鞋和静电衣和帽子，然后就参加培训，培训的内容，我已经记不太住了，唯一能记住了就是停叫等 中午吃完饭，就过去产线那边了。 下午（大概中午一点多），在班组长的安排下，一直在瞎转悠（主要原因貌似是因为那条线产品貌似在试产，所以没活干），我们两个（还有一个同事）就到处走，期间还去上面那条产线帮一个小姐姐拧螺丝。说实在的，以前开玩笑说考不上就去打螺丝，没想到我们连螺丝都打不好，别人打十个，我才能打一个，并且经常出问题，还得别人帮忙收拾手尾。之后出于不要继续打扰别人工作和实在不好意思再继续丢人，我们就跑到最下面那条线和一个小哥聊天了，聊天的主要内容还是那些工作内容啊，以及双方对于作息的好奇吧，期间探讨了家庭因素吧。他说：以前感觉父母不理解他，双方总是比较多的争吵，直到上次把说出来父母根本不理解他，双方关系才比较缓和。这我个人感觉也是时代困境吧，时代变化太快了，快到上一辈也根本反应不过来，我自己也反应不过来，所以我一般就很少和自己父母谈论这些了，毕竟每个人都会面临着时代赋予的挑战和压力，也很少有人能够设身处地的站在对方所在的时代去考虑和思考，我也觉得这个是个难题吧。 第二天就有事情干了，我是被安排到贴标签那个岗位 贴标签相对来说还是细节还是较少，也比较简单，几分钟就懂流程了。之后便是边贴边聊天了。让我对于这次安排印象较深的就是旁边的那个小哥，平白无故就说：指条明路给他。说实在的，我现在也是处于迷茫区，也不知道未来何去何从，也无力反抗大势，更别说指条路了，甚至于我还想有人给条路走。是的，我个人认为一个人只有不停止思考和学习，总能明白何去何从的吧。但是他身处在如此工作强度和麻木的环境中，他自己也说自己没有时间思考，也算是自身困境吧。我能干两天，就提桶跑路，而他呢？只希望我们各自安好，一起加油，共同寻觅属于我们自己的人生意义和价值吧！ 此刻，我仍然未能理解教育的意义所在，但我庆幸过去的自己随着教育大势慢慢砥砺前行~~~"},{"title":"‘XCP协议’","path":"2022/01/22/‘XCP协议’/","text":"XCP协议XCP（Universal Measurement and Calibration Protocol）协议，XCP”中”X”是Universal，通用的，表示能适配它能够支持多种底层网络协议和总线类型。XCP的主要应用于测量和标定ECU内部参数。此协议能够使数据采集工作与ECU内部运行的任务和中断同步，从而保证每当ECU软件更新参数时，能快速采集到所需的参数值。 XCP允许对内存直接进行读写访问：这样在读访问中就可以用来测量来自内存的参数数值，写访问中就可以用于调整内存中参数的数值。 XCP协议框架为了确保传输网络的独立性，XCP被分成一个协议和一个传输层。由于XCP在功能方面增强了很多，所以不能向后兼容CAN标定协议（CCP）。同时ASAM已经对XCP协议定义了下列传输层定为标准： 基于CAN的XCP 基于LIN的XCP 基于SxI（SPI、SCI）的XCP 基于以太网（TCP/UDP）的XCP 基于USB的XCP 基于FlexRay的XCP XCP协议数据结构主、从设备之间每次传输的数据都采用XCP帧的格式，包含一个XCP报头、XCP数据包和XCP报尾。XCP帧支持的传输层可将这三个帧元素映射到相应的传输帧格式。 XCP数据包包含独立于所选传输机制的协议数据，携带标识、时间戳和实际数据。PID是标识字段的一部分，用于标记数据包及数据包内部的数据值。 在XCP中，测量/校准的工具侧是“XCP主结点”，被测量的ECU侧是“XCP从结点”，采用所谓的“主从通信方式”。这种通信方式中，必定是从主结点发送命令来开始，从结点在接收到后，再向主结点发送应答，以这样的顺序进行通信。如图7所示，1个网络上主结点必定只有一个，而从结点可以有多个。 在这个情况下，主结点向每个从结点发送命令，并接收从结点返回的应答 图8：一主多从的通信示例 通过这种通讯方式，车载网络上连接一个测量/校准工具（= XCP主结点）后，可以通过XCP协议访问作为测量对象的各个ECU（= XCP从结点）。 网络和传输方式在网络上，只要能区分“从主结点发送到从结点”和“从从结点发送到主结点”，这两种类型的通信，就能够使用XCP。在“XCP on CAN”的情况下线束工程师，是通过用两个CAN ID，“从主结点发送到从结点的ID”和“从结点发送到主结点的ID”进行区分。在网络上使用区分的通信并传输一些内容时，XCP使用了三种传输模式（图9）。 图9：XCP的传输模式 对于传输模式而言，可以在主结点侧和从结点侧，分别决定使用哪种模式。例如，主结点为“块传输模式”，从结点为“标准模式”，这样的使用方式也是可行的。因此，尽管主结点的工具侧的性能强大，但是当从结点的ECU只能使用有限的资源时，也可以实现简化的传输模式。 CTO/DTO在XCP中，除了主结点和从结点之间的传输方向的差异之外，要传输的内容还被分为“与XCP本身的控制相关的通信”和“与数据相关的通信”两种类型，以及定义在每个网络上传输的报文的格式。作为对比，前者被称为“命令传送对象（CTO：Command Transfer Object）”，后者被称为“数据传送对象（DTO：Data Transfer Object）”。 CTO：Command Transfer Object的缩写 CTO是与XCP自身的控制命令和应答等相关的对象。控制命令从主结点发送，对命令的应答是从从结点发送。 DTO：Data Transfer Object的缩写 DTO是与同步从结点（ECU）获取数据测量结果以及进行数据变更相关联的对象。同步数据变更被称为“激励（Stimulation）”，但由于是测量/校准以外的功能，因此省略详细说明（详情请参照XCP标准文件）。 图10展示了，从XCP标准文件的“Part2 1.1.1 The XCP Packet Types”章节中，抽取的XCP主结点与从结点之间的CTO和DTO的关系。 图10：XCP主结点/从结点间的对象 报文格式和PID如上所述，CTO和DTO是不同报文格式（图11），可以分别设置主从设备的最大报文长度。 MAX_CTO：CTO的最大报文长度（字节）MAX_DTO：DTO的最大报文长度（字节） 图11：CTO和DTO的报文结构 所有的XCP报文都在这个最大报文长度内，命令和响应等内容都在一个报文中完成的。而且在报文格式中，每个字段按两种类型分配给CTO和DTO报文。此外，报文的第一个字节是被称为“PID”的标识符，是被用来区分是怎样的报文。 主结点对从结点进行XCP控制时使用“命令（CMD）”，此时的PID在“0xC0”到“0xFF”的范围内。从结点对这个命令返回肯定应答的情况下，使用“应答（RES）”，此时PID变为“0xFF”（图12）。 图12：报文的标识符（PID） 除了测量/校准的同步数据交换之外，所有其它的都是通过主结点发送命令，从结点将返回肯定应答来完成的。在此，以XCP on CAN为例来说明，其中主结点发送到从结点的CAN ID是“1”，从结点发送到主结点的CAN ID是“2”。在这种情况下，XCP通信按以下顺序执行。 主结点发送的CAN ID为“1”，其中第一个字节指定为“0xFF”，第二个字节指定为“命令参数”。 从结点接收第1行的连接命令，并通过PID识别该命令。 从结点发送的CAN ID为“2”，其中第一个字节指定为“0xFF”，第二个字节开始指定为“应答值”。 主结点接收第3行的应答命令。 图13显示了实际通信的跟踪结果。第1行的“0xFF”是命令“CONNECT”，从而在主结点和从结点之间建立逻辑连接，并接收后续命令。 图13：CONNECT命令和应答 访问测量/校准对象XCP的测量/校准，是通过对ECU内部的软件的访问来实现的。具体而言，针对要测量/校准的对象的内存区间，通过指定对应的“XCP地址”的方式进行访问。 XCP地址与普通的微控制器中的地址几乎相同，但XCP使用了32位的XCP地址和8位的扩展地址。也就是说，主结点对从结点的访问，可以有32 + 8 = 40位的地址空间。这个地址与XCP的实际ECU内存不需要完全匹配，其字节序（Endian）也可以针对每个从结点来选择。因此，在车载网络上可以连接到多个ECU，即使存在不同的地址空间（16位，32位），或者不同的地址字节序，主结点都可以经过适当处理，使得所有的都可以测量/校准。 异步测量XCP除了同步测量，还可以做异步测量。异步测量是使用主结点发送的命令，通过指定的XCP地址来提取从结点的ECU内部的数据，并通过从结点的应答将该数据传送给主结点，如此循环往复来实现的。为了取出数据，使用PID为“0xF4”的命令“SHORT_UPLOAD”。这个命令和应答的格式如下所述。 SHORT_UPLOAD命令： CTO 0字节位置，指定为PID“0xF4”CTO 1字节位置，指定为取出字节数。最大为MAX_CTO – 1字节CTO 2字节位置，保留字段CTO 3字节位置，指定为要读出的8位扩展地址CTO 4~7字节位置，指定为要读出的32位地址 SHORT_UPLOAD应答： CTO 0字节位置，指定为PID“0xFF”CTO 1~MAX_CTO字节位置，指定为取出的数据图14是主结点使用“SHORT_UPLOAD”，在XCP扩展地址为“0”、XCP地址为“0x00124A5C”的位置，每100ms取出4字节的过程的跟踪结果。 图14：通过SHORT_UPLOAD命令的测量 同步测量在上述异步测量的情况下，主结点决定了测量时间。为了使测量与ECU的控制相匹配，有必要由ECU确定测量时机，并在数据取出来后由从结点发送到主结点。这种数据通信是通过DTO来完成的。 主结点在进行同步测量之前，通过命令指定要取出的数据的XCP地址，从结点在等到同步测量开始命令后，使用DTO发送到主结点。因此，在同步测量的情况下，不是通过命令和应答的组合，而是通过测量周期或事件，由从结点发送DTO报文到主结点。 图15展示了，由“START_STOP_SYNCH”命令开始的测量同步，从结点持续地将测量数据通过DTO报文发出，直到收到“START_STOP_SYNCH”命令才停止的实际的跟踪结果。 图15：同步测量的开始和停止 以下是对同期测量中，对ECU的控制应用程序的测量时机，主结点和从结点的任务分割的说明。ECU的控制应用程序： 当到达测量的控制周期，或者事件发生时，进行处理并通知到XCP从结点。 主结点： 确定要同步测量的内存及其测量周期，指定同步测量的XCP地址，并使用命令启动和停止同步测量。 从结点： 它管理从主结点指定的同步测量的XCP地址。然后，从检测的开始同步测量后，直到停止之前，会根据上述ECU的控制应用程序传达的被管理的XCP地址，从取出内存值并发送DTO报文。 XCP与同步测量相关的术语和概念关于同步测量，在XCP标准文档中使用了各种术语。这里我们解释一下主要的术语和概念。 元素（Element）： 通过XCP地址来指定的一个测量对象的内存。 对象描述表（ODT：Object Description Table）： 归并元素的测量内存，在一个DTO报文中聚集最多的可发送的内存的表。 ODT条目（Entry）： 为创建ODT的元素的测量对象的XCP地址。 DAQ列表（List）： 这是一个ODT的集合。这决定了在一个同步测量的周期或者事件触发时要测量的内存数量。ODT与一个DTO报文相关联，由MAX_DTO - PID决定了最大的大小，但由于实际测量的内存可能会大于此值，因此分为了ODT和DAQ列表。 事件通道（Event Channel）： 在同步测量的控制周期和事件触发的通道，也即是“种类”的意思。同步测量的时序都是基于这个事件通道的。 同步测量的处理 下面将说明，在同步测量中，ECU的控制应用程序向从结点发送测量的时机，将执行怎样的处理。 （1）控制应用程序要通知从结点测量时机。这个通知通常是将事件通道作为参数，来调用从结点的驱动过程来实现的。（2）针对主结点以ODT条目来指定的测量对象的内存地址，从结点使用缓冲区来管理，在每次被控制应用程序调用时，都会根据该缓冲区来读取指定地址的内存。（3）读取的内存以ODT为单位合并，并以DAQ列表来生成DTO报文。图16展示了，元素和ODT条目、DAQ列表和ECU控制应用程序之间的关系。当ECU的控制应用程序集成了Vector的从结点驱动程序后，调用C语言函数“XcpEvent(事件通道)”，就会根据ODT条目的缓冲区，从ECU内存中读出元素的值来创建出DTO报文。 图16：XCP和控制应用程序的关系 测量对象和DTO报文图17展示了，作为测量对象的元素从在ECU内存，到在网络上传输的DTO报文之间的关系。 在图17中，是根据ODT条目测量的七个元素的结果，取出的“0x19”“0x6C”“0xF0”“0xBF”“0xC0”“0xA9”“0x02”，作为一个ODT的DTO报文就创建好了。在这个DTO报文中，PID包含在第一个字节，测量时元素的内容被包括从第二个开始的字节中。像这样的，PID的值是从“0”到“0xFB”的DTO报文被称为“DAQ”。 就像这样，从作为测量对象的ECU内存、管理测量对象的ODT的DAQ列表、决定测量时机的控制应用应用程序和用于区分测量时机的事件通道开始，到最后使用DTO报文将测量数据发送到主结点，就实现了同步测量。 同步测量的选项除了上面描述的那些之外，根据测量的规模和用途，还有XCP同步测量的各种使用形式。下面将介绍这些使用形式中比较典型的例子。 动态DAQ：通过增加管理测量目标的DAQ列表中的ODT及其条目的数量，可以增加测量的测量点的数量。而且通过维持与要测量的事件通道数量一样多的DAQ列表，可以对ECU的所有测量时机进行测量。但是这些数量的增加会增大ECU中的管理缓冲区，因此会消耗ECU的内存。 而且如果ECU具有10ms和25ms的控制周期，有的10ms的控制周期中测量的测量点的数量很大，别的25ms的控制周期中测量的测量点的数量也很大，根据测量的场景不同，测量点的数量会有不同。对于这样的应用程序，有一种称为“动态DAQ”的功能，可以允许从结点动态更改每次测量的DAQ列表、ODT和ODT条目的数量。相反的，如果在集成XCP驱动程序时，这些数量是预先确定的，则称为“静态DAQ”。一个从结点将具有静态或动态DAQ功能。 带时间戳的DAQ：在主从结点间的通信中，如果因为加入网关而造成时间差，又或者因为使用无线通信，使得通信时间出现波动的情况下，同步测量中的测量时间对于主结点来说是“不确定”的。为了防止这种情况，要使用“带时间戳的DAQ”。在从结点侧，包含测量时间的时间戳的DAQ，通过DTO报文传送给主结点。而收到这个报文的主结点，可以读出所添加的时间戳来知道正确的测量时间。 校准校准是为了重写ECU内部软件中的参数，而从主结点发送指定XCP地址的命令和重写数据的命令，从结点会对应的导出适当的参数地址、执行重写，并返回一个应答。图18显示了，根据XCP主结点发送的XCP扩张地址“0”、XCP地址“0x0041D5C8”，将该地址开始的2字节的参数，重写为“0x0064”的示例的跟踪结果。 图18：通过DOWNLOAD命令的校准 其它的XCP功能XCP仅在测量/校准方面就还有很多的功能。除了这次我们介绍的之外，还包括诸如对ECU中的闪存之类的非易失性存储器的访问功能、对ECU的访问保护的功能等许多功能。 出处：https://www.suncve.com/introduction-to-xcp-part-2/"},{"title":"can Bus off","path":"2022/01/22/can-Bus-off/","text":"Can Busofferror active 轻微的 error passive被动错误 bus off 总线关闭 REC（接受错误计数器） TEC（发送错误计数器） 1、什么是CAN Bus Off举例： 车上一个ECU 1, 一直向总线上发送消息，可怎么都发送不出去。 如果这个累计到一定的次数（255），按照CAN总线协议：ECU 1自己的进入 BUSOFF模式，这个时候ECU 1 一时半会是不能发送信息了。 这个TX error count 超过255，ECU就必须进入Bus Off 状态，并需要逻辑上断开总线 2、总线Bus Off之后会做何处理ECU 1在自己内部检测到BUS OFF后，默默的从逻辑上退出了总线，暂时他没妨碍大家，ECU 1他自己也搞不明白啥回事，于是ECU 1拿着小本子，记下了 x年x月x日x时x分x秒, 但是汽车电压，里程，xxx 是多少多少，我bus off 了 3、Bus Off时计数的变化规律bus off是个非常集体的概念， ECU自己发送失败，TX error count + 8， ECU自己发送成功，TX error count - 1， 这个TX error count 超过255，ECU就必须进入Bus Off 状态，并需要逻辑上断开总线 4、CAN frame 的一些常见错误发送ECU检查： 有无ACK CRC检查，CRC Delimiter, ACK Delimiter，EOF等 BIT监控， 送的那个ECU，自己校对每个BIT，看有没有都送对（ID区域，和ACK区域除外） 接收ECU检查： CRC检查，CRC Delimiter, ACK Delimiter，EOF等 检查有无联系6比特是全0、或全1的 总线关闭（bus off）是CAN节点比较重要的错误处理机制。那么，在总线关闭状态下，CAN节点的恢复流程是怎样的？又该如何理解节点恢复流程的“快恢复”和“慢恢复”机制？下面将为大家详细分析总线关闭及恢复的机制和原理。 一、 故障界定与总线关闭状态为了避免X某个设备因为自身原因（例如硬件损坏）导致无法正确收发报文而不断的破坏总线的数据帧，从而影响其它正常节点通信，CAN网络具有严格的错误诊断功能，CAN通用规范中规定每个CAN控制器中有一个发送错误计数器和一个接收错误计数器。根据计数值不同，节点会处于不同的错误状态，并根据计数值的变化进行状态转换，状态转换如下图所示。 图1节点状态转换图情形1 以上三种错误状态表示发生故障的严重程度，总线关闭是节点最严重的错误状态。并且，节点在不同的状态下具有不同的特性，在总线关闭状态下，节点不能发送报文或应答总线上的报文，也就意味着不能再对总线有任何影响。 状态跳转和错误计数的规则使得节点在发生通信故障时有了较好的自我错误处理和恢复机制，从一种较严重的错误状态跳转到另一种严重性相对较低的状态，本质上就是一种恢复过程。图1所呈现的转换过程是CAN通用规范所要求的，我们从设备供应商买回来的CAN控制器已经把这些功能固化在硅片之中。 在通信过程中，错误主动和错误被动两种状态下节点的恢复过程一般不需要MCU进行额外的编程处理，直接使用CAN控制器固有功能即可。但对于总线关闭状态，往往不直接使用CAN控制器固有的恢复过程，而是对其进行编程控制，以实现“快恢复”和“慢恢复”机制。 注： 1、由于篇幅有限，关于错误计数的详细规则以及各状态下节点的具体特性不在本文进行讨论，读者可以查阅CAN的相关协议规范。 2、本文的“CAN控制器”是指已经实现了CAN通用协议物理层和数据链路层所要求的功能和特性的器件，如SJA1000；而“节点”是指把CAN控制器与MCU、收发器等相关器件进行整合开发出来的具有一定功能的CAN节点。 二、 为什么需要对总线关闭状态的节点实现“快恢复”和“慢恢复”策略？当节点进入总线关闭状态后，如果MCU仅是开启自动恢复功能，CAN控制器在检测到128次11个连续的隐性位后即可恢复通信，在实际的CAN通信总线中，这一条件是很容易达到的。以125K的波特率为例，12811（1/125000）= 0.011264s。这意味着如果节点所在的CAN总线的帧间隔时间大于0.011264s，节点在总线空闲时间内便可轻易恢复通信。我们已经知道，当进入总线关闭状态时，节点已经发生了严重的错误，处于不可信状态，如果迅速恢复参与总线通信，具有较高的风险，因此，在实际的应用中，往往会通过MCU对CAN控制器总线关闭状态的恢复过程进行编程处理，以控制节点从总线关闭状态恢复到错误主动状态的等待时间，达到既提高灵活性又保证节点在功能上的快速响应性的目的。具体包括“快恢复”和“慢恢复”策略，两种策略一般同时应用。 通过以上的讨论，我们可以知道，节点进入总线关闭状态后，存在以下几种恢复情况： （1）MCU仅开启CAN控制器的自动恢复功能，节点只需检测到128次11个连续的隐性位便可以恢复通信，恢复过程如图1所示。 （2）MCU没有开启CAN控制器的自动恢复功能，也不主动干预总线关闭错误，节点将一直无法“自动”恢复总线通信，只能通过重新上电的方式使节点恢复, 恢复过程如图2所示。 图2 节点状态转换图情形2 （3）MCU对CAN控制器的恢复过程进行编程处理，这时，节点的恢复行为由具体的编程逻辑决定，各厂家普遍采用了先“快恢复”后“慢恢复”的恢复策略，恢复过程如图3所示。 图3 节点状态转换图情形3 三、MCU如何实现“快恢复”和“慢恢复”？MCU编程实现总线关闭“快恢复”和“慢恢复”的一般过程可用以下流程图描述： 图4 MCU实现总线关闭恢复流程 节点以正常发送模式发送报文的过程中，如果出现了发送错误，发送错误计数会增加，只要发送错误计数没有超过255， CAN控制器便会自动重发报文，如果出现多次发送错误，使发送错误计数累加超过255，则节点跳转为总线关闭状态。MCU能够第一时间知道节点进入了总线关闭状态（例如在错误中断处理逻辑中查询状态寄存器的相应位），这时MCU控制CAN控制器进入“快恢复”过程，即控制CAN控制器停止报文收发，并进行等待，计时达到需要的时间T1（如100ms）后，MCU重新启动恢复CAN控制器参与总线通信，这样便完成了一次“快恢复”过程。 节点每进入一次“快恢复”过程时，MCU会对此进行计数，当节点“快恢复”计数达到设定的值N（如5次），则后续再次进入总线关闭状态时MCU把恢复总线通信的等待时间T2进行延长（如1000ms），这样便实现了“慢恢复”过程。“快恢复”和“慢恢复”过程的主要区别就在于恢复节点参与总线通信的等待时间的不同。 通过MCU对于总线关闭后的恢复行为进行编程控制，实际上是对CAN控制器的错误管理和恢复机制进行了补充，使得总线关闭状态后的恢复过程更加灵活，更能适应实际应用的需要。对于 “快恢复”和“慢恢复”的等待时间，以及“快恢复”计数多少次后进入“慢恢复”过程，不同厂家可根据具体的需求进行编程实现。 错误类型在CAN总线通信中，一共有五种错误： 位错误：节点将自己发送到总线上的电平与同时从总线上回读到的电平进行比较，如果发现二者不一致，那么这个节点就会检测出一个位错误。 ACK错误当发送节点Node_A在ACK槽时间段内没有回读到显性位，那么发送节点Node_A就会检测到一个ACK应答错误。这表示没有一个节点成功接收该帧报文 填充错误：在需要执行位填充原则的帧段（数据帧遥控帧的SOF~CRC序列），检测到连续六个同性位，则检测到一个填充错误。 CRC错误：发送节点Node_A在发送数据帧或者遥控帧时，会计算出该帧报文的CRC序列。接收节点Node_B在接收报文时也会执行相同的CRC算法，如果接收节点Node_B计算出的CRC序列值与发送节点Node_A发来的CRC序列值不一致，那么接收节点就检测到一个CRC错误。 格式错误 这两个计数器计得不是收发报文的数量，也不是收发错误帧的数量。TEC和RCE计数值的变化，是根据下表的规定来进行的"},{"title":"Autosar（中级篇）","path":"2022/01/22/Autosar（中级篇）/","text":"Autosar(中级篇)一、通信相关机制1、Signal GroupsSignal Groups，信号组。也就是将一些作用相近的信号放到一个组里面方便管理。在下一节中会讲到一个信号的失效性，如果放在一个组里面的信号有一个失效了，那么这个信号组的所有信号都被认为失效。这么做是为啥呢？比如现在我有一个陀螺仪传感器的三个姿态的信号放在一个Signal Groups中，这个时候假如陀螺仪失效了，那么这三个姿态信号其实有一个是失效了，这三个信号都是没有意义的（姿态解算就会出问题），所以这个Groups里的三个信号都显示为失效。 Signal Groups由通信矩阵定义，所以一般是由OEM设计 2、Update Bit简单的说就是在Signal中将一个bit保留用做Update Bit，这个Update Bit一般是和下一节我们会讲到的Deadline Monitoring超时监控一起来使用的。这个位是专门用来指示信号是否被应用层更新了，如果长时间没有被更新，就启动超时处理。比如下图所示，我们从左往右分析： 发送方在应用层更新了Signal A的数据，然后COM模块就自动的将Update Bit置位，表示这个信号被更新了；这时Signal B没有被更新所以Update Bit还是0 然后将Signal A和B通过通信传给接收方 接受方收到Signal A和B之后开始解析，发现Signal A被更新过了是可用数据，就进入Signal Notification去处理了；但是Signal B没有被更新，就进入超时监控处理去了 Update Bit由通信矩阵定义，所以一般是由OEM设计 3、Notification MechanismsNotification Mechanisms，通知机制。通知主要有下面几类，常用的就是接收（Rx indication）和发送（Tx confirmation）成功的通知，都是在Communication-&gt;Signals中做配置的。 但是通知具有一个重要属性：立即通知（Immediate）和 延迟通知（deferred），这个属性是在Communication-&gt;PDUs中配置的  立即通知：就是接受/发送成功立即中断式的进入通知函数  延迟通知：不是马上就通知，在下一次在Task中调用Com_MainFunctionRx()或者Com_MainFunctionTx()的时候触发通知 4、Deadline Monitoring （1）超时监控Deadline Monitoring，超时监控。超时监控之前在Update Bit中也提到过，但是超时监控可以分为两个等级：  IPDU级：当一个Rx IPDU没有在规定的时间内收到有效数据，就启动超时处理  Signal级：就是之前我们说过的Update Bit的方式，如果没有收到Update Bit，就启动超时处理 值得一提的是：在Dev和Cfg（COM）中都可以配置Deadline Monitoring的Timeout Time，但是最后都是要同步到Cfg中做代码生成的。还有一点是IPDU的Timeout Time的来源是在IPDU中的Signal的最小Timeout Time。比如也就是说IPDU中有两个Signal，Signal A的Timeout Time=100ms，Signal B的Timeout Time=50ms，那么这个IPDU的Timeout Time = 50ms （2）超时处理 COM的超时处理 超时之后会有一个超时的Notification被调用：Rte_COMCbkTOut_  可选：可以选择将超时的信号复位位初始值（需要配置ComRxDataTimeoutAction） RTE的超时处理 超时之后可以触发一个Runnable来处理 在使用相关Rte_Read__的时候会返回错误RTE_E_MAX_AGE_EXCEEDED 在使用Rte_IRead这样的Buffer类型的S/R接口的时候，状态可以由Rte_IStatus决定 5、Invalidation（1）失效机制Invalidation，失效机制。之前也是提过一嘴，当一个Signal Groups中任何一个Signal被设置为无效的时候，整个Groups就都被设置为无效了，不允许一半有效一半无效的Signal Groups出现。失效的信号可以通过Rte_Inmalidate(explicit API)或者Rte_IInvalidate(implicit API)来发送一个失效值 （2）失效处理失效的处理有三种方式：  Keep: 保持原值不变  Replace: 用一个初始值替换  None: 不做任何处理，等于是这个失效机制没有起作用 6、Data Mapping概述在Davinci Cfg中，数据是不能直接放在IPDU上的，必须要映射到相应的Signals上才行。Signals一般是由通信矩阵定义的，但是通信矩阵并不知道程序中究竟用的是哪个数据进行传输的，因此需要将我们在Dev中定义的数据（Data Elements）和Signal（Network Signals）相映射才可以正常使用。在Davinci中，映射可以至下而上，也可以至上而下，说人话就是在Cfg中和Dev中都可以配置这一功能，之后导入到另一方中就行了，但也分为两种情况：  在ECU SW Composition这个层级中： 在Cfg和Dev中都可以配置Data Mapping；但是需要做Delegation Ports，也就是将我们的通信ports做一个逻辑上的与其他ECU相连的操作  在Atomic SWCs这个层级中： 只能在Cfg中做配置，同时不需要做Delegation Ports 首先来说一下在Dev中做Delegation ports的操作，在我们完成端口的实体化之后，可以右键-&gt;Complete Ports…，然后出现下图的对话框，选择Delegation Ports only，然后就能看见端口延申出去了，含义是连接上了更高一层级的SWC 下面就是在Dev中做Data Mapping后，出来的效果 在Cfg中也会出现相应的信息显示 7、我们的数据是如何层层的传输到总线上，这些跨层级的传递是如何配置的 二、模式管理在BSW层中，当满足一些规则（Rules）的时候，执行相应的动作（Action），这就是模式管理 模式管理中，经常会用到的几个概念：  Mechanisms for notification: 通知机制。比如在模式切换的时候会发出一个通知，告诉我们需要被通知的地方（比如应用层的某个SWC）模式切换了  Service requests for mode changes： 应用层可以主动请求一个模式切换  Mode arbitration： 模式仲裁。也就是判断当前状态是否满足Rules，需要进行模式切换不  Mode control： 模式控制。也就是执行相应的Action 1、BswM概述BswM就是一个基于Rules的服务模块，主要工作就是上面讲到的根据制定的Rules，执行相应的Action。下图之前我们放过一次，这里多讲讲：可以看到这里有三个Auto Configuration，那都是DaVinci自动配置的部分，然后下面的Miscellaneous就是我们用户自己定义的部分（当然其实一般来说都不必自己定义）。 还有一点是，对Rules的评估是可以有两种形式的：立即 和 延迟  立即：当然就是被call了之后立马开始了  延迟：在被call之后，需要执行到BswM_MainFunction()这个函数的时候，才开始，所以会有一定的延迟 （1）BswM执行流程还是举个实际的例子，大家可能比较容易理解，这里就找了自动配置中的Ect State Handing中的InitToWakeup来说明： 首先在Rules中大家可以看到ESH_InitToWakeup这个规则，而这个规则首先需要一个表达式，表达式可以在下面的Expressions中定义，这个定义也会出现在图中蓝色方框里面的地方。这里就是说当ECU的状态处于Init初始化的时候，就满足了我们的条件 2.我们接着看，在Rules下面就是我们在规则判断为真时执行的Action List（Action List就是几个Action的集合体）。从图中的Action List可以看到有三个Action，分别做了三件事：  ESH_Action_OnEnterWakeup: 调用BswM_ESH_OnEnterWakeup()这个Callout函数  ESH_Action_SwitchWakeup: 通知我们的SWC，进行模式切换  ESH_Action_ESH_Wakeup: 请求我们的被调模块进行模式切换 3.到这里为止，BswM的工作就完成了，接下来就需要被调的Bsw模块自己进行模式切换了 2.EcuMEcuM其实有两种定义：Flexible（灵活的）和Fixed（固定的），一般来说我们使用的都是Flexible的方式，Fixed一般会用在AutoSAR 3.x上。所以我们重点讲解Flexible的EcuM 其实EcuM很好理解，就是管理Ecu状态的，至于Ecu的状态，基本就是OFF、UP和SLEEP了。但是这其中又包含很多其他的内容，比如在UP的时候，会需要初始化BSW、OS和RTE等；对唤醒事件的处理等内容的处理。说白了，EcuM就是用来管理EcuM的上下电和睡眠这些模式的。 这里还要谈谈EcuM和BswM的关系，因为大家经常会混为一谈，觉得Ecu比Bsw大，就像EcuM能管住Bsw一样，其实他们的关系并非上下级，而更像是合作的关系。BswM会和很多的带M的模块交流，来配合管理其模式，所以EcuM也是一样，BswM能和EcuM交流来管理其模式（所以上面的BswM中我们才能配置Ecu State Handing嘛）。但是EcuM会管理到Ecu的上下电的状态，所以假如Ecu都下电了，那还谈何的BswM模式管理。所以他们两更算是分工合作的。 (1) EcuM 的上下电流程上下电，说白了就是给Ecu上下电后，Ecu的代码执行顺序。这里还讲到了大家可能经常会用到的Sleep流程，主要就是可以归纳为以下这张图，大家掌握这张图就基本掌握了EcuM的上下电流程了。这张图的具体内容博主将在下面做进一步讲解，大家看完本节后再回头看看这样图，就能理解了 上电（StartUp） 上电的流程，大家可以类比着我们的Windows或者Linux操作系统来考虑。主要分为四个阶段： 上电： 首先是由cstart.c这样的引导代码，引导CPU跳入mian()函数。然后在main()函数中做OS的初始化准备（这时还没启动OS，只是初始化；就像ADC_Init 和 ADC_Start的区别） 预启动OS： 在预启动的阶段，会进入EcuM_Init，在这里面会做一些Error的判断，最后就是启动OS了 启动OS之后： 启动OS之后，会进入到一个Task中，被称为Init Task，这里会调用EcuM_StartupTwo()函数，在这个函数中主要做了SchM和BswM的初始化，并且在这里就通过BswM可以将ADC、PORT等这些底层的驱动模块都初始化了 启动BswM之后： 启动BswM之后就算是完成了Startup的阶段，然后会进行Rte_Start()，之后就进入了UP的阶段了，算是可以正常运行了 下电（Shutdown） 大家使用单片机的时候经常是只管上电，不管下电的。但是一旦有了OS之后，下电的流程也是必须的，就像我们从来没有见过Windows在点击关机之后立马就息屏了吧？一般都会看见一个正在关机的字样。所以下电也是有一套流程的 所以下电的流程也可以分为这么四个阶段： BswM通知EcuM下电： 最关键的就是EcuM_GoDown()这个函数，当调用之后，就进入到EcuM的下电流程了 预关闭OS： 这里面就是做一些Deinit的操作，然后设置一下下电的设置，最后关闭OS 关闭OS： 这里会调用一个ShutDownHook()，来让用户处理关闭OS的一些定制工作 关闭OS之后： 这里会依据不同的下电需求（直接关机还是重启），进入到不同的动作中去 睡眠（Sleep） 睡眠模式大家可能不是最常用的，但是在消费级的一些小家电上会经常看到这种状态，因为睡眠模式一般是为了节能。进入睡眠会有两种模式：Poll或Halt，就是不断循环或停止的模式。 准备睡眠： 就是GoSleep阶段，先使能唤醒源，然后指定唤醒源当前的状态，最后GetResource，这之后将由EcuM接管。 进入睡眠： 睡眠有两种状态：  进入Poll的话：先设置MCU状态Mcu_SetMode(ECUM_SLEEP…)，然后执行EcuM_Mainfunction，进入后就是激活唤醒源，然后不断的检查是否被唤醒了  进入Halt的话：先设置Global Suspend，然后生成Ram Hash，接着设置MCU状态Mcu_SetMode(ECUM_HALT…)，然后Global Restore使得全局恢复。如果在Halt下想要唤醒，需要检查Ram Hash 唤醒： 首先设置MCU状态Mcu_SetMode(ECUM_NORMAL…)，然后禁止唤醒源，接着重启各类底层驱动，最后就是RelsaseResource，唤醒之后由BswM接管 (2) BswM 配置 不过既然是自动配置的，其实我们也不用太在这里花时间，记住一点就行：那就是勾上我们在ESH中需要用到的选项。注意直接打勾是勾不上的，必须点进去Configure Ecu State Handing这个页面里才能打勾，这里一般能勾的全勾上就行 Module Initialization 这个初始化是位于OS启动后，在初始化BswM之后，由BswM进行对所有BSW中可管控模块的初始化。所以理论上来讲，Port、Dio这些也都可以在这里初始化，在图中勾上就可以了 这 三、网络管理AutoSAR网络管理的目的其实就是为了降低汽车的功耗，当网络上没有信息交互时，网络将进入睡眠模式。AutoSAR的网络管理（Network）是通过网络管理报文（NM Message）实现的，主要分为三大模式：  网络模式（Network Mode）  预睡眠模式（Prepare Sleep Mode）  睡眠模式（Bus-Sleep Mode） （1）Network Mode当处于网络模式时，可以正常的收发普通报文，CAN收发器处于正常的工作状态。当ECU上电后通信网络会自动进入Bus-Sleep状态，然后通过唤醒源唤醒后进入Network Mode的Repeat Message State中 1、Repeat Message State（帧重复状态） 当进入Repeat Message State后，会根据设定按照一定的周期重复的发送一系列的NM Message，目的是告诉其他的节点，我当前的节点被唤醒了。这里又要分为主动进入和被动进入Repeat Message State： 主动进入就是我的节点因为有报文要发送，需要激活我的通信网络来发送报文，就要主动进入Repeat Message State 被动进入就是因为其他节点进入后发送了一系列重复的NM Message，而收到这些NM Message的节点就被被动进入了 上图中当ECU1要发送消息给ECU2了，这时它会主动进入Repeat Message State，开始自己这个节点的网络传输，当它快速的发出了第一帧NM Message（就是上图中蓝色的向下箭头），ECU2接收到这一帧NM Message之后，ECU2被动进入Repeat Message State，同样也开始重复的传输NM Message，当这两个ECU都发足了规定数量的Repeat Message后分别进入各自的Normal State中 还有重要的一点： 当进入Repeat Message State后，会开启一个计时器T_NM_TIMEROUT，这个计时器在发送或收到一帧NM Message的时候会自动清零，当计时器处在Normal State或Ready Sleep State下的时候如果超时就会进入到Prepare Sleep Mode，也就是触发进入Prepare Sleep Mode的条件 2、Normal State（正常运行状态） 在正常模式下，NM Message也会周期性的发送，防止T_NM_TIMEROUT超时。每次发送NM Message就会更新T_NM_TIMEROUT。当这时ECU不再准备发送和接收数据后，就可以进入到Ready Sleep State，Ready Sleep State不再发送NM Message 3、Ready Sleep State（准备睡眠状态） 在Ready Sleep State下，还有其他节点会发网络管理帧保持网络唤醒，此时ECU处于等待进入Prepare Sleep Mode，T_NM_TIMEROUT仍然会因为NM Message而清零。所以这样的结果就是，当网络上所有的ECU发出了最后一帧NM Message（之后没有ECU再发送NM Message），大家都同步清零T_NM_TIMEROUT，如果设置的T_NM_TIMEROUT相同，会同步进入Prepare Sleep Mode阶段 4、Prepare Sleep Mode 到这个阶段的时候，就是等待，让所有的节点有时间结束网络活动，所有的总线静默。然后在等待T_WAIT_BUS_SLEEP时间后，所有节点进入Bus-Sleep Mode 5、Bus-Sleep Mode 当ECU上电后会默认进入Bus-Sleep Mode，而且网络其实是在不断的试图进入到Bus-Sleep Mode中，但是由于有NM Message在总线上的传输，所以才能保留网络模式不进入Bus-Sleep Mode中。大家可以想象成看门狗，NM Message就是不断的喂狗，一旦没有NM Message，就进Bus-Sleep Mode 四、ComMComM就像一个通信的总开关，它可以管住CAN、LIN和以太网等相关的通信网络。主要有三种状态：  Full Communication（全通信）  Silent（静默状态）  No Comunication（不通信） ComM可以通过NM（Network Manager）去保持network的唤醒，同时也可以通过SM（State Manager）去激活通信，总而言之就像一个通信的总管。下面会通过两种唤醒源来解释一下ComM的状态机。 1、内部唤醒 当ComM初始化的时候会首先进入到No Communication中，这个状态下会不断循环的去判断有没有本地或者远程的唤醒请求 这时在循环中判断出本地通信请求Api执行，则开始了往Full Communication走（Allow 通道、让CanSM打开通信） 然后这时NM会处于主动激活状态，会快速的发送一系列的NM Message。之后就进入了Full Communication 进入Full Communication后由于是内部唤醒，会首先进入Network Requested，执行正常的发送接收信息的状态，能一直主动去保持Network的唤醒状态 一旦本地COM Mode释放后，则进入Ready Sleep状态 如果这时其他ECU也都没啥要通信的，Network进入Prepare Bus Sleep状态后，ComM开始停止Tx IPDUs，不再发送数据，进入Slient状态 在Slient状态下如果收到了NM Message，则又回到Full Communication中 在Slient状态下如果没有收到NM Message，并且这时收到了NM Bus-Sleep的指示，则让CanSM去关闭通信，然后进入No Communication的状态 2、外部唤醒如果被外部唤醒，NM会进入被动状态（Passive）。然后当ComM进入Full Communication后也会默认往Ready Sleep状态里面去跑，不会去保持Network的唤醒状态 3、状态关联 只有当EcuM处于UP状态下才能保持ComM的Full Communication状态和Slient状态 CanNm的状态机就是上一节中我们讲到的那些内容，这里以状态机图的形式展示出来了 ComM能全权负责本ECU的通信状态，也就是管理SM模块，但是Network的状态不光是本ECU有关，还和其他的ECU有关，所以ComM对NM是有一定的协调作用，并非全权管理 五、服务映射大家可以想象一下，我们的BSW的模块那么多，当我们配置好了以后，如何和我们的应用层实现交流的呢？比如，当我们配置好了EcuM模块，EcuM有一个功能是管理ShutdownTarget，也就是确定我在Shutdown之后是关机呢还是重启呢，这一点有时需要应用层指明。那么当我们配置好了EcuM模块之后，EcuM会留出一个标准AutoSAR接口供应用层调用，但是我们的AppL和BSW之间是有RTE阻隔的，所以需要进行Service Mapping，在AppL和BSW之间架起一道鹊桥，将这个标准AutoSAR接口与我们的AppL间接相连（也是需要RTE管理的） 六、BSW 中的存储模块1.NvM（Nonvolatile Memory Manager）也像是ComM一样，是一个总管。ComM是负责总管通信，而NvM负责总管存储；同样的，ComM可以管理CAN、LIN这些总线，NvM可以管理Flash、EEPROM这些存储器，都做到了对不同硬件统一的管理。NvM主要具有以下的功能： 1、排队管理机制 当有数据想要存入Memory的时候，由于Flash和EEPROM都需要先擦除再写入，速度会比RAM慢很多，所以会产生数据的排队。  而排队机制可以手动配置是FIFO或者是带有优先级的队列这两种方式  可以配置队列的深度  支持立即数据（immediate data，即要求立即写入的数据，比如crash data）的快速写入，即可以不用排队 2、上下电的存储处理 之前在讲上下电的时候，图中应该会有一些关于Memory的处理，就是通过NvM来做出处理  在上电的时候，要读取NV里的必要的数据  在下电的时候，要将必要的数据写入NV里面 3、支持数据校验 主要利用CRC校验检查是否数据出错  当校验出错时，触发使用默认数据（直接使用或者也可以CallBack） 4、数据的写保护 就如同我们写Flash要先解锁一样；还有一种方式是设置成单次写入，仅允许写入一次 5、对数据的冗余存储 主要就是增加一些关键数据的可靠性 2 FEEFee（Flash EEPROM Emulation）是对Falsh仿EEP的一个抽象的具体实现。Flash被抽象成了一个一个的Flash Sector，Flash Sector又分为了一个一个的Flash Page。  Flash Sector： 就是Flash能擦除的最小单元，也可以配置为更大  Flash Page： Fee只能通过Flash Page去访问Flash，也就是Fee的最小单元，Flash Sector包含Flash Page，如下图： 下面两点需要大家注意： Fee会调用Flash驱动（FLS）去实现对硬件的真正的擦除和写入等功能；但是Flash由于寿命的原因，不能老是擦除同一个地址的Flash，所以Fee还会自动管理写入的地址，尽量平均的去写入数据 Fee对Flash写入的时候，是会先备份一遍的，再进行擦除。也就是说我们至少需要两个Flash Sector。过程是：首先将要擦除的Sector的数据都备份到另一个Sector中，然后擦除该Sector，之后一个page一个page的写入数据，直到将这个Sector写满 3 EaEa（EEPROM Abstraction）是对EEPROM 的抽象，它也是调用EEPROM的驱动（EEP）来实现最终的操作，同样，它也会考虑EEPROM的寿命问题来将存储的数据做一个均摊。但Ea与Flash不同是，EEPROM不用一块一块的擦除，它比较灵活，可以定点写入数据。所以它可以以交替的形式把一个Block写入几个Memroy Locations里面，如下图： 4 NVRAM Block同通信的PDU一样，存储功能也需要一些特殊的数据结构来存放和管理我们的NV数据（NV data） NVRAM Block的作用类似于IPDU，但它们两仅仅只是作用上相似，其功能实现是完全不同的。首先用户是不可能直接操作NV Memory的，所以肯定需要开辟一块RAM区域用于暂存我们的NV data；然后我们的数据需要校验，那么肯定需要有一个空间来存放我们的校验是否正确等必须信息；假如校验出错，我们还需要从某个地方获取该值的默认数据以作为错误处理。所以我们的NVRAM Block就被AutoSAR设计成下面这样了： NVRAM Block分成四个子Block组成，其中NV Blcok、RAM Block和Administrative Block是必须存在的；ROM Block是可选的 NV Block存储于NV Memory（EEPROM、Flash），可以选择是否添加Header和CRC校验 RAM Block就是NV Block在RAM中的一个映射，因为应用层不能直接操作NV（那样太慢了），所以基本上是一个1:1的结构 ROM Block一般是当出错时读取其中的默认值来取代出错值（ROM只读不能写入） Administrative Block用来保存NVRAM Block的一些属性、错误和状态信息，也用来存放datasets的信息（dataset下文会讲到） NVRAM Block的这些可选项都由NVRAM block descriptor来配置，工具中可以看到该配置。 NVRAM block descriptor还能配置NVRAM Block的几乎所有选项，包括像优先级、类型等选项 NVRAM Block的类型 NVRAM Block里一般都只包含1个RAM Block、1个Administrative Block和0/1个ROM Block。但是NV Block可以包含多个，根据包含了几个NV Block，我们将NVRAM Block分为三种类型：Native（正常）、Redundant（冗余）和Dataset（数据集）  Native： 即一个RAM Block保存到对应的一个NV Block中  Redundant： 将一个RAM Block保存到两个NV Block中，当一个数据失效后可以使用另一个  Dataset： 最多支持255个NV Block，类似于一个数组，可以用DataIndex来索引其中的数据 5 Fee BlockFee Block是在Fee中使用的Block，以一种叫做 “Chunks” 的方式来做管理。一个Chunk可以包含几个Blocks，而Chunk之间是用一种链表的形式连接起来的，Chunk就是其中的节点 值得注意的是： 假如NVRAM Block的Block Length假如是16，那么Fee Block的Block Size应该要加上CRC长度（CRC16加2，CRC32加4）。所以假如是CRC32，那么Fee Block的Block Size就应该为20。下面的Ea Block也是一样 七、Diagnostics1.UDS协议统一的一个通用标准协议；如今各个厂商也可以根据自己的需求，对其进行裁剪和定制。和XCP协议类似，UDS协议是建立在通信协议（例如CAN，目前绝大多数用的CAN，也有部分使用以太网）的上层协议  对于诊断上位机和ECU之间是必须具有诊断协议才能完成诊断工作  诊断协议包含了许多的诊断服务，这些服务是真正作用于诊断上位机和ECU之间用来传输的  诊断协议包含了诊断上位机发送给ECU的数据和信息，也包含ECU的应答，是双向协议 2、CanTP主要作用 CanTp是位于PduR和CanIf之间的一个模块，主要提供以下服务： 分割发送方向上的数据 重组接收方向上的数据 控制数据流 检测分割会话中的错误 说白了就是诊断的协议中有时会出现超过8个字节的服务，这个时候就需要使用多个CAN报文去发送这个服务的内容，所以需要CanTP去做分割。同样在接收的时候，也需要做重组 3、诊断传输流程 DCM首先遵循UDS协议，根据我们上一节讲的规则组成UDS-PDU给到PduR PduR敏锐的看出这是CAN报文，所以它选择将UDS-PDU转变为I-PDU给到CanTP CanTP看了看这个I-PDU，将其拆分成SF(简单帧Single Frame，如果一个I-PDU不超过8字节，则表示为简单帧)、FF(首帧First Frame)和CF(连续帧Consecutive Frame) CanIF再将这些帧发给Can Drv Can Drv通过物理总线发送给诊断上位机"},{"title":"Autosar(入门篇)","path":"2022/01/18/Autosar-入门篇/","text":"Autosar（入门篇）AutoSAR主要分为3个层级：应用软件层（AppL），实时运行环境（RTE）和基础软件层（BSW） 应用软件层主要就是用来存放我们自己的代码的地方 实时运行环境是提供应用层所需的资源，同时将应用层和底层隔离 基础软件层是将硬件做封装，一直封装到一个标准的操作系统的状态，以便上层可以标准化调用系统服务，这里又分几个部分，马上将会讲到 应用软件层 该层是由一个一个SWC组成的，每个SWC咱们可以理解为一个.c文件，而整个应用软件层就是一个文件夹 实时运行环境 一个不太恰当的比喻：把BSW比作我们的windows系统，AppL就是开发的应用软件，而RTE更像是一个虚拟机，将上层应用和底层操作系统隔绝开的同时，又兼容了不同厂商开发的软件。（实际上更像是电话转接员的工作） 基础软件层 基础软件层又分为4大部分： 硬件抽象层（MCAL）：可能用过STM32的童鞋应该都知道库的概念，硬件抽象层又叫MCAL，就是将芯片的寄存器操作都封装成一个AutoSAR规定的统一的库Api。就是说这套Api是不同厂商都支持的，但是底层怎么实现，就是芯片厂商的事了。同时也有软件工具EB，可以通过界面配置MCAL功能 ECU抽象层：如果说MCAL只封装了芯片，那么ECU抽象层就是将硬件上所有的硬件都进行了封装。比如我们的控制器上有一个主芯片英飞凌的TC275，还有采样电路，电源电路，CAN电路等等。而MCAL就是封装了芯片上有的功能。而ECU抽象层就是将所有的这些都做一个统一的封装。所以不管硬件是如何实现的，这里封装后，也形成了统一的Api 服务层：这里有是更加高级的一层了，服务层里是包含操作系统（OS）的。OS将使用ECU抽象层的Api，再对上层暴露出服务接口，其实就是嵌入式实时操作系统（RTOS）所作的工作。 复杂驱动：又叫做CDD，主要工作是将AutoSAR未定义的一些功能封装起来，给应用层提供接口来调用这些功能。（简单说就是其他的概念） 一 工具链上来讲目前主要是2大流派： MATLAB + DaVinci（国内主流，参考书籍有《基于AUTOSAR规范的车用电机控制器软件开发》） MATLAB + ETAS Matlab： 大家应该都很熟悉了，主要是用Simulink做代码生成的，就是我们的应用层软件就需要Matlab来开发，当然手写也是可以的 DaVinci Developer： 主要用来设计AppL的程序架构 DaVinci Configurator pro： 主要用来配置BSW和自动生成RTE的 EB Tresos： 主要用来配置MCAL的，可以兼容英飞凌和恩智浦的芯片 Vector还有其他的一系列的工具：比如Canoe、Canape等，这里就暂时略过 二 AppL 概述1. AppL的组成AppL中最重要的就是SWC了，而SWC与其他SWC通信需要接口，每个SWC中又由runnable组成，所以AppL主要的组成就分下面三部分： 应用软件组件（SWC） AutoSAR接口（Ports）和连接器（Connector） 可运行实体（Runnable） 2. SWC的通信SWC之间的通信是通过应用软件层外进行了，我们称其为虚拟功能总线（VFB）。该总线是意义上的片内外通信的结合体，取了个名字叫虚拟功能总线，其实际就是分两部分： 在片内就是通过RTE通信。前面章节说了，一个SWC可以理解为一个.c文件，那么c文件间怎么通信呢——全局变量。所以大家可以把ECU内部SWC的通信暂时先想象成全局变量，具体怎么实现的，在后续RTE章节中将做详述 在片外就通过片外总线通信（一般汽车上都是CAN Bus） 3 .SWC 的类型（1）、原子级的SWC（Atomic SWC）原子级的SWC（Atomic SWC）：顾名思义，就是不可再拆分的SWC，其实之前我们列举的都是Atomic SWC。它们的特点是对应一个.c文件，这个c文件就是我们的最小单元，不可再分。由有人会问，那可运行实体（runnable）不就是组成SWC的更小单元吗？确实如此，但是我们将SWC看成原子，那runnable就是其中的电子、质子和中子，它们与原子密不可分。因此将SWC看成是最小单元，runnable是其中的函数。每个SWC的功能基本都是用来实现特定的算法。 （2）、集合级的SWC（Composition SWC）有不可分割的SWC，就肯定有可分割的SWC。所以AutoSAR还规定了一类集合级的SWC（Composition SWC）。它们可以分为一个一个更小的Atomic SWC。就好像是一个分子由很多原子组成的概念。分子是有实际意义的，很多原子就没有实际意义（但是有些也有，比如金、银和铜等）。类比来看，我列了一个表： 还是那个例子，我们可以将功能相近或者需要整合到一处方便观看的SWC（以后Atomic SWC都简称为SWC）利用一个compositon SWC包含起来。这样，就可以方便SWC归类 注意： 在Vector的DaVinci中其实不会生成Composition的文件夹，这里是为了方便大家理解添加的。其实Composition只是一个概念，是用来在配置工具上方便大家归类整理，看起来顺眼的 （3）、特殊的SWC 实际上，需要添加代码的不止是应用层的SWC。在BSW中，IO硬件抽象层（IoHwAb，BSW章节中会讲到）和复杂驱动（Cdd)都是需要手动添加代码的，而这两个地方也可以算作是SWC，在DaVinci Developer中都是可以作为SWC进行配置和加runnable等操作的。因此，我们将其算成是特殊的SWC来看待 4.Ports的类型（1）、接口的类型Ports是SWC和SWC做接口（Interface）通信使用，或者SWC通过RTE和BSW做接口（Interface）通信使用 Ports主要分为5种类型，列在下面的图中： 可以分为：Send/Receiver（S/R）接口和Client/Server（C/S）接口。而S/R接口是用来传输数据的；C/S接口是用来执行操作的。 （2）、S/R接口 作用： 传输数据。通过RTE传输数据，并且通过RTE管理数据的传输，避免数据出问题（例如同时调用同一数据时可能出错） 一个接口可以包含多个数据，类似于通过结构体传输 可以传输基础数据类型（int，float等）和复杂数据类型（record，array等） 再说具体一点，举个例子调用接收接口 Rte_Read_&lt;Port&gt;_&lt;Data&gt;() //这里的xx是指的传输的数据内容，比如DoorOpen就是 SWC_DoorOpen = Rte_Read_Door_DoorOpen(); （3）、C/S接口作用： 提供操作。就是Server提供函数供Client调用 可以同步和异步。同步就是直接调用，相当于函数直接插入上下文运行；异步的话需要等待，相当于让函数在另一个线程中运行，运行完了再返回，原上下文依然运行 一个接口可以提供多个操作，就是一个接口可以包含很多函数 ECU内部和跨ECU都可以调用，跨ECU也是通过外部总线 再说具体一点，举个例子调用客户接口： Rte_Call_&lt;Port&gt;_&lt;Function&gt;() //这里的xx是指的调用的函数，比如调用State()就是： Rte_Call_Door_State(); 5.Runnables可运行实体Runnable就是SWC中的函数，而在AutoSAR架构在被DaVinci软件生成的时候，Runnable是空函数，需要手动添加代码来实现其实际的功能。 Runnable可以被触发，比如被定时器触发、被操作调用触发或者被接受数据触发等。 补充一点的是：Runnable是需要OS中的Task做载体的。这句话是什么意思呢——runnable是函数，但是再c文件中光有一个函数那没用，必须要调用该函数才能起作用，就必须要有操作系统中的任务来执行这个函数。类比于Windows中的线程就是Task，runnable就运行在线程上这种感觉。值得注意的是：而操作系统和AutoSAR架构是两回事，Task不是架构里的概念，而是操作系统中的概念，在AppL中没有Task这个概念，不可混为一谈。 三. RTE概述1、什么是RTERTE的作用有点像一个快递中转站或者说是电话接线员（就是上个世界那种要先打电话到接线员那里，然后通过接线员转接电话线到目的地），其作用就是将一个SWC的信息通过RTE连接到其他SWC或者BSW上。且RTE具有管理这些信息的功能，比如接收的SWC正忙（您所拨打的用户正忙），那么RTE负责让发送信息的SWC等待，或者做其他处理；RTE还能触发SWC，就像是这时接收的SWC在睡觉，这时发送的SWC发信息来了，那么RTE就要把接收的SWC叫醒起床。一句话概括就是RTE提供了SWC的运行环境 2 .RTE的作用 提供 跨ECU / ECU内部 的通信管理。 提供 对runnable的管理功能（触发、唤醒等，简单说就是runnable需要映射到Task上运行嘛，而这个映射就是通过RTE具体实现的） 之前我们不是提到了VFB（虚拟功能总线），RTE就是VFB的具体实现 在Vector的工具链中，RTE是自动生成的 3.RTE对Runnables的运行支撑通过RTE给runnable提供触发事件。 之前说过了runnable是可以被触发的，就是需要通过RTE来实现这个触发和调用runnable，具体在下面讲解 通过RTE给runnable提供所需资源。 就是之前说的接口通信（Ports那节），将runnable需要的一些资源通过接口传输给它 将BSW和SWC做隔绝。 因此OS和runnables也被隔绝了，runnable的运行条件由RTE提供，不能由OS直接提供 4.Runnables的触发条件RTE给runnables提供触发条件，也就是runnable在设计的时候，需要有触发条件，不然无法运行，也就没有意义了。触发条件就是一些特定的事件，AutoSAR中主要规定了以下一些触发条件（图中是DaVinci软件中的配置项，灰色是因为我没有配置，不用在意）： 初始化事件：初始化自动触发  定时器事件：给一个周期定时器，时间到了就触发 接收数据事件（S/R）：Receiver Port 一旦收到数据，就触发 接收数据错误事件（S/R） 数据发送完成事件（S/R）：Send Port 发送完成，就触发 操作调用事件（C/S）：当调用到了该函数的时候 异步服务返回事件（C/S）：之前说过C/S可以在异步下运行，就是说当我调用一个Server函数，但是我是异步调用的。那么该被掉函数作为一个线程和当前的运行程序并行运行，当被调函数运行结束返回（Return）的时候，这时触发异步服务返回事件 模式切换事件 模式切换应答事件 5.RTE对Ports的支撑扮演SWCs和BSW的交流途径  作为VFB的具体实现  作为S/R接口的通信实现  作为C/S接口的通信实现  ECU内部通信/跨ECU（通过COM）  实现AR-COM的回调功能，具体实现是在SWC中完成的，RTE负责完成这个回调机制 (1)、直接调用（Direct）相当于有一个全局变量，runnable可以直接读写这个变量 用的是下面的语法：(注意和data的区别，带&lt;&gt;的是指全局data的名字，不带&lt;&gt;的data是局部变量的名字，这里使用指针，就是说操作的是同一个地址，没有复制使用；同时，这些函数都是在runnable中使用的，不要看是Rte，就以为是RTE中的代码，因为调用的是RTE的机制，所以这里是Rte) Std_ReturnType Rte_Read_&lt;port&gt;_&lt;data&gt; (&lt;DataType&gt; *data) Std_ReturnType Rte_Write_&lt;port&gt;_&lt;data&gt; (&lt;DataType&gt; data) (2)、缓存调用（Buffered）相当于将全局变量先复制到一个runnable的局部变量中，再操作这个局部变量，最后把这个局部变量再赋值到全局变量中。在runnable操作这个局部变量期间，全局变量是不会改变的。 使用方法如下：（都是由RTE管理的，用户只需要正确调用函数就ok） &lt;DataType&gt; Rte_IRead_&lt;r&gt;_&lt;port&gt;_&lt;data&gt; (void) void Rte_IWrite_&lt;r&gt;_&lt;port&gt;_&lt;data&gt; (&lt;DataType&gt; data) 3、队列调用（Queued）因为数据不止一个，是一组队列的数据，就像我们常用的串口FIFO。因此，可以设置循环接收或者等待接收，等待的话是有超时管理的 调用代码如下 Std_ReturnType Rte_Receive_&lt;port&gt;_&lt;data&gt; (&lt;DataType&gt; *data) Std_ReturnType Rte_Send_&lt;port&gt;_&lt;data&gt; (&lt;DataType&gt; data) 4、C/S接口的实现之前在第二章AppL中讲过了C/S接口，这里再更加深入的说明一下其实现的原理：首先，C/S接口就是客户/服务接口，这个接口就是客户来调用服务端的操作的一个接口。也就是我写着写着，发现我想要调用一个函数，这个函数在其他的C文件中，就让RTE帮忙调用。 而这里又有两种方式：异步和同步： 同步就是说我这个人很懒，我要等服务端运行完了这个函数，RTE返回这个函数的结果后，我才开始继续我的工作； 异步就是我这个人很勤快，我通知RTE让它帮忙告诉服务端运行函数后，我就继续干我的事了，等过一段时间后，我估摸着函数运行结束了，我再请求函数结果 5、C/S接口的不同方式同步和异步调用不是通过函数区别的，这必须是事先配置好由RTE生成的，所以在Davinci中配置runnable的port时是有这个选项的（当然要C/S接口才有） 从上文的例子，可以看出，同步调用其实就是我们平时调用函数是一样的，就是等同于将被调函数代码嵌入当前调用的函数代码中运行即可（其实这叫直接调用，同步调用也可以mapping到task上，这里我们不展开讲解，防止大家混乱） 用代码实际说明一下 //假如我们的被调函数是： Std_ReturnType RunnableServer(int *param) //那我们的客户中应该写的调用函数就是： Std_ReturnType Rte_Call_&lt;Port&gt;_RunnableServer(int *param) //这个param就是我们希望被调函数操作的变量 异步调用相当于有两个线程，一个线程运行我们的原函数中的内容，另一个执行被调函数的内容。然后可以过一段时间去读取一下被调函数的返回结果 而这时，如何知道被调函数是否执行完了呢？有三种方法： 循环检测，就是在那一直等，等到返回值为止，这样的话和同步就差不多了，意义不大 超时检测，定一个时间，时间到了就去读取，没到的时候继续运行我的程序 事件触发，当服务函数运行结束，RTE可以触发原函数，告诉它被调函数运行完了，你可以读取返回值了 读取函数也用代码实际说明一下 //执行下面的函数后就能将参数返回回来了 Std_ReturnType Rte_Result_&lt;Port&gt;_RunnableServer(int *param) 6.RTE对数据一致性的管理什么是数据一致性 数据一致性，就是当多个用户试图同时访问一个数据库，它们的事务同时使用相同的数据时，可能会发生以下四种情况：丢失更新、未确定的相关性、不一致的分析和幻想读。 说的通俗一点：就是当多个操作同时读写同一个数据的时候，很有可能出bug（实际是由于优先级的问题，可能出现我们的数据被篡改的情况，造成作者不想看到的数据结果） (1)、数据一致性的实现机制利用RTE管理 这部分类容之前说过了，就是利用RTE来管理这里的数据，防止bug出现。比如IRead，大家都操作的是数据的备份，不直接操作原数据 (2)、SWC内部变量这个内部变量就比较神奇了，因为它可以直接在DaVinci中配置，runnable可以直接调用，就类似于一个c文件中定义的全局变量，没有被extern出去。在c文件中定义的函数时可以直接使用的。那么这时就会出问题了，同一个c文件中的函数是可能被放在不同Task上运行的，就可能出现这些函数在同一时刻运行的状况，那么在调用这个全局变量的时候，就可能出bug。那么要如何解决呢？AutoSAR做了以下两种方式： EAs(Exclusive Areas,专用区域)：就是下面两句代码，相当于一个关中断，调用变量的语句放在里面，运行时不能有更高级的Task打断被保护的语句 ...... Rte_Enter_&lt;name&gt;(); //这里放置被保护的语句 Rte_Exit_&lt;name&gt;(); IRVs(Inter-runnable variables,跨函数变量)：还是两句代码，上面的EAs是整段代码段都被保护了，而这里的两句就相当于在改变变量的时候被保护，也就是这两句话执行的时候被保护 Rte_IrvWrite_&lt;re&gt;_&lt;name&gt;() Rte_IrvRead_&lt;re&gt;_&lt;name&gt;() 7.RTE与Interface接口AutoSAR接口 一句话概括： 之前说的S/R和C/S接口就是AutoSAR接口 标准接口 一句话概括： 就是AutoSAR规定的C语言API 标准AutoSAR接口 一句话概括： 就是AutoSAR接口，不过名称是由AutoSAR官方规定不能修改 四 BSW概述中文翻译就是基础软件层（Basic Software）。这个基础软件层实质上就是将整个ECU分层封装起来，一直封装到OS。就好像是windows一样，可以在不同CPU、不同GPU、不同主板等的设备上运行一样。我们的ECU就像是电脑硬件，ECU上的主芯片就是cpu，AutoSAR OS在这里就可以看成是windows。这么比喻应该容易理解了吧，但是我们并不是很关心BSW中的OS，因为是可以由软件直接生成，我们这里最关心的是如何为我的OS提供必要的硬件和软件支持。而针对千奇百怪的ECU产品，需要设置不同的配置来满足OS和上层的需求，这件事就是BSW来做的。 为了一层一层的将硬件剥离开，BSW设置了三层软件层，越往上层和硬件的关系越小。 1.BSW的结构（1）、微控制器硬件抽象层（MCAL）如果接触过Arm的童鞋，应该听过库的概念。简单说就是将芯片的寄存器操作都封装称API函数，方便用户调用。这里的硬件抽象层也是一样，是将芯片上的功能都封装称一个一个的API函数，供上层调用，而这些API函数是AutoSAR规定好的。针对不同的芯片，在这一层就可以做到对上层的接口完全一致。这样的好处就是，当配置好了之后，同一个操作可以兼容所有芯片。 （2）、ECU抽象层微控制器硬件抽象层是对ECU上主芯片的抽象和封装，而ECU抽象层就是对整个ECU的封装。什么意思呢：ECU上不光有主芯片，还有其他的一些设备（比如外置存储，外置看门狗等），这一层就是对ECU上包括主芯片在内的所有设备的封装。当然，这些设备其实也是要通过主芯片控制的，比如外置看门狗，就需要和主芯片相连接，由主芯片的接口去配置它。因此，其底层还是需要MCAL的支持 （3）、服务层服务层里面就包含了我们的操作系统OS，同时是将下层的功能统一汇总到这里，将所有与硬件想关的功能都抽象成一个具体应用服务（比如通信，这里就将CAN、I2C和串口等一系列的通信统一抽象称COM通信，应用层可以无需知道该通信具体是走哪种通信方式）。相较于之前说的API，这里的说的服务可能不是很好理解，大家也可以看成是一种API，但是是封装更高级，与应用层密切相关的API。 具体功能：（这里的具体流程将在后续详细讲解）  诊断（Diagnostics）  存储管理（NVRAM Management）  看门狗管理（Watchdog Manager）  通信（Communication）  操作系统（OS）  调度管理（Schedule Manager）  ECU状态管理（ECU state management）  通信通道管理（Com Channel Management） （4）、复杂驱动复杂驱动算是个另类了，为啥另类呢，因为它不属于BSW三层结构中（不在五行中，跳出三界外）。它的作用相当于补充的作用，在BSW三层结构中没有定义的，但是实际中会用到的就可以写到这里 2.BSW的I/O功能架构与术语解释这里主要是说I/O的功能，而其中会用到一些模块，下面途中我将用到的模块都高亮显示了，并且放大到了右边的途中展示其中的子模块（该子模块就是BSW中最小的单位了，如其中的ADC子模块）。这里要强调的一点是：I/O并非是我们经常说的GPIO，这里的I/O包括了DIO（数字输入输出，就等同于单片机上的GPIO）、ADC和PWM 下面我将详细解释上图子模块的功能：  I/O Signal Interface： 对输入数据的初步处理，比如输入消抖  Driver for ext. ADC ASIC： 外置ADC的驱动，比如当有外部ADC采样芯片的时候，通过SPI通信，将数据传入主芯片。这里就需要有对外部ADC处理的驱动模块  Driver for ext. I/O ASIC： 同上，只不过这里是I/O  SPI Handler： SPI处理驱动，将硬件中的SPI封装成API供上层调用（有的使用的是I2C，这里就不单独列出来了，大家把图中的SPI改成I2C就行了）  ADC PWM DIO： MCAL中的驱动，将硬件中的ADC、PWM、DIO分别封装成API供上层调用  SPI ADC PWM DIO（Hardware）： 就是指芯片中的这些功能模块 值得一提的是，I/OHwAb是需要手写代码的（当然也可以Matlab生成，这里的手写是指非AutoSAR的代码，需要我们自己添加），在DaVinci中可以申请一个SWC声明为IOHwAb，来作为一个c文件，在其中添加代码（说白了就是当成SWC使用）。 传感器信号流 首先是车内肯定有个环境的，环境也一定会有一些属性，比如温度，湿度等。我们就拿我们最常用的温度举例 我们假定使用的是最简单的热敏电阻传感器，那么通过传感器，我们就将温度信号转变为了电阻的大小 光有电阻是不行的，ECU上肯定还有一个分压电路，使得我们的电阻值通过电压的形式传入我们的芯片（因为我们的芯片ADC只能读取电压值嘛，不可能直接读取到电阻值） 进入芯片后，就到了软件的处理范围了 首先是由芯片ADC采样，这里就需要MCAL发挥作用了，加入我们配置MCAL中的ADC为周期触发，并且连续采样，那么ADC将会周期性的将我们的采样值（比如12位ADC采样到410，最大值为4096）放入我们规定的数组中等待被读取 IoHwAb之前说过了也可以当作SWC看待，里面也是有Runnable函数可以加代码的，所以这里是通过MCAL的api函数Adc_ReadGroup读取存放在ADC数组中的值，然后将其转化为电阻值等待上层调用 到Sensor SWC这里就进入了AppL层了，它Get到IoHwAb的电阻值后转化为实际的温度值发送给我们的Application SWC 到这里我们的采样就完成了，下面将进入执行阶段 执行器信号流 首先，在采样到了温度后，我们的Application SWC会根据当前的温度和设定的温度做对比，算出一个需要的功率（比如用PID控制算法，温度低了就要加大功率，高了就减） 假设这里的温度调节设施也就是一个简单的发热电阻，在Actuator SWC中将功率转换成需要的电流，I^2*R=P嘛 在IoHwAb中将电流值转换成电压值（欧姆定律嘛），并将该电压用PWM的形式传给MCAL，其实我们能控制的也就只有电压值；电流值、功率和温度都是我们间接通过电压控制的 MCAL收到PWM信号后就开始在芯片的引脚口上产生PWM，这里就从软件到了硬件 由于PWM等效于电压调节，所以我们这里的电压可控，电流就可控，功率也可控，最后温度就可控了 3.BSW的Communication功能 模块详解： COM： 从应用层传下来数据首先就进入这里，应用层无需关心收发的数据是通过什么总线传输的，应用只需要将它传输给COM即可。这些收发的数据是由用户的DBC文件或者ARXML文件已经定义好了的（这些文件一般OEM整车厂在整车设计的时候就做出来了，里面有总线的网络拓扑图，每个传输的数据应该走什么总线都有定义，所以应用层是无需关心的，只需要优雅的将数据和COM交换即可）。同样，COM上传的数据也是很单纯的数据，里面没有这个数据是什么总线上传的这样无意义的信息，应用层关心的是这个数据的实际意义和数据大小。所以COM主要就起了一个信号接口和网关的作用 PDU Router： PDU——Protocol Data Unit，协议数据单元。这个模块的功能就是将COM下发的信号数据分配到相应的协议总线上去；或者将不同的协议变成同一信号上传给COM。 IPDU Mux： 用于解析一些特殊的协议，比如CAN FD或者用户自定义的一些协议。就是起了一个统一CAN ID，不同信号Layout的作用 CAN Tp： 分包数据传输与错误检测，一般来说只有在诊断的时候才会使用 CAN Interface： 与硬件已经无关了，与硬件相关的是下面两个Driver做的工作，这个Interface主要可以配置收发队列；组帧(FlexRay)；管理时间触发总线的调度表(LIN, FlexRay) CAN Driver： 就是MCAL中对主芯片上CAN模块的驱动封装 Trcv Driver： Trcv——Transceiver的缩写，就是收发器驱动的意思。如果是外置CAN收发器，这里就要用到Trcv Driver这个驱动，而非CAN Driver 发送流程 应用层Send一个数据进COM COM写信号进PDU Buffer中 PDU被PDU Router立刻发送或按周期发送（每个PDU都有一个独立的ID），之后PDU Router辨认总线种类，并把PDU发向不同的下级模块 Interface根据不同的通道，把报文写入不同的队列 Driver根据报文的优先级立刻发送报文 接收流程 硬件接收报文 由Driver发出Rx中断（函数），之后通过RxIndication，数据被传递到Interface 传递到PDU Router 传递到COM（如果SWCs使用Data ReceptionTrigger，就通知RTE；否则暂存到Buffer中） 信号被RTE读取，然后应用层读取 4.BSW的Memory功能总所周知，用户能用的ROM存储方式现在一般有两种：EEPROM和FLASH仿EEPROM；而存储可以是片内的，也可以是片外的。 因此，一般就有2*2=4种ROM存储方式： 主芯片片内FLASH仿EEPROM 主芯片片内EEPROM（前提是该芯片内有的话，很多低端一点的芯片都不带片内EEP） 板载片外FLASH仿EEPROM 板载片外EEPROM NVRAM Manager: 简称NVM，是应用层访问非易失性数据的唯一接口，提供非易失数据的管理服务。这里是统一按块编写的，不关心是哪种存储类型；写完后有回调函数通知Memory Abstraction，然后再通知NVM  Memory Abstraction Interface: 主要作用是将需要读写的信息解耦，分别分派给EEPROM或FLASH  EEPROM Abstraction: EEPROM的抽象层，主要作用就是进一步封装片外或片内EEPROM驱动，给上层提供统一的API接口  Flash EEPROM Emulation: 同上，此为Flash  External E² Drv: ECU抽象层中片外EEPROM的驱动，下面是SPI的驱动，由于片外的EEPROM要通过SPI通信才能访问。因此，片外EEPROM的驱动要放到ECU抽象层中。  Ext Fls Drv: 同上，此为Flash  SPI Handler Drv: MCAL中对片上SPI的驱动  EEPROM Drv: MCAL中对片上EEPROM的驱动  Flash Drv: MCAL中对片上FLASH的驱动  SPI EEPROM FLASH: 片内的SPI、EEPROM和FLASH功能模块  External E² Memory: 片外EEPROM，就是板载的EEPROM，需要通过SPI访问  External flash Memory: 片外Flash，就是板载的Flash，需要通过SPI访问 （1）片内存储片内其实没什么好说的，比较简单。图中的两种颜色的箭头分别代表了从EEP和FLASH存储数据的流向，最终到达主芯片上的EEPROM和FLASH。它们不经过片外驱动、SPI和片外设备。 （2）片内存储用过片外存储的童鞋应该相对了解一些，大部分都是用的SPI通信，加上一些其他的控制命令，如果是我们直接手写，就需要查阅存储芯片的手册，然后配置SPI，再将定义好的命令通过SPI发送进去。而AutoSAR其实也是一样的，只不过是将这么些流程封装成了模块，使得这个流程看起来更加清楚了。大家可以看看下图中的流程，对比一下片内的流程。 5 BSW的Mode Management功能Mode Management：模式管理，可以理解为对状态的管理（比如ECU的上电、下电和休眠；CAN通讯的开启和关闭都是状态）。主要管理的对象有ECU、BSW和COM（通信中又可以细分很多）。由于服务层很多概念不用分的很明确，因此我没有将其分开画出来，大家知道是用了系统服务和通信服务就行了，不必纠结比如ComM到底是属于哪个服务的（虽然其是系统服务的）。模式管理其实很复杂，大家可以在后续的实验课中感受一下，这里还是先做简单说明 ECU State Manager(EcuM): ECU状态机，主要作用是管理的是ECU的上下电功能（还包括休眠、重启等）。官方手册给出了具体有以下四个功能： 单片机初始化时，初始化OS所需的BSW模块 为单片机的休眠（Sleep）模式和唤醒（wake up）模式做准备 执行关机命令和重启命令 通过唤醒验证协议验证已发生的唤醒 Basic Software Mode Manager(BswM): 主要作用是定义一系列规则。一旦满足规则，就执行相应的动作。主要有Communication Control、Ecu State Handing和Module Initialization，而这些都是软件自动生成的。如果要自己添加规则，可以在Miscellaneous中添加（一般自动生成就好） Communication Manager(ComM): 主要功能是管理通信的启用和关闭  Network Management(Nm If, Bus NM): 主要功能是保持总线唤醒和协调总线关闭  Bus State Manager(Bus SM): 切换Bus的状态，比如CAN SM是切换该CAN的启动和关闭（注意把CAN和COM区分开，COM更高一层，COM不光包含CAN） 6 BSW的Watchdog功能 WdgM: 为应用层提供安全相关的服务 WdgIf: 看门狗接口，主要功能是触发硬件看门狗 Wdg Drv: Mcal中看门狗的驱动 7.BSW的Diagnostics功能我们应该要了解诊断是如何实现的 ECU故障发生了，那么在事后我们去维修的时候，维修师傅如何知道是什么出问题了呢？那么就需要将发生的故障记录下来，所以就要将故障的内容记录到EEP或者Flash中，所以下图中将会用到NVRAM Manager及其更底层的模块（由于之前介绍过，这里省略掉了） 维修师傅是不可能直接读取EEP或者Flash中的内容的，因此还是需要用到CAN传输数据到维修师傅的诊断设备上的，因此这里就有了communication的一些模块。但是这些信息并非是应用层直接下发，所以这里用的是DCM而非COM 故障发生的时候，肯定是需要做出应急反应的，所以就还需要对故障做处理的功能  FIM: Function Inhibition Manager，功能禁止管理。也就是当一些error出现的时候，禁止一些功能。比如当检测到控制器过电流的时候，关闭MOS或IGBT，防止炸管。就是说有一部分SWC是需要使能条件的，这些条件取决于故障内容（就是来源于下面的DEM中），而FIM负责根据故障内容关闭一些SWC或执行一些SWC  DEM: Diagnostic Event Manager，诊断事件管理。就是用来记录和存储诊断事件的，下面连接NVRAM Manager，就是将这些诊断事件记录到EEP或者Flash中  DCM: Diagnostic Communication Manager，诊断通信管理。实现诊断通信协议，我们通常说的UDS协议（即ISO14229，是Unified Diagnostic Services，统一诊断服务，是诊断服务的规范化标准，比如读取故障码应该向ecu发什么指令，读数据流又是发什么指令），就是在这里配置的 8.BSW的OS功能OS的可扩展性AutoSAR OS可以分为四个等级：SC1、SC2、SC3、SC4 （SC：Scalability Classes，可伸缩的类型），下面列出一张表来看看具体区别 其实很容易看出来，就安全性来讲，SC4 &gt; SC3 ~= SC2 &gt; SC1  SC1： 包含标准OSEK OS标准，除此之外还定义了标准的计数器接口和轮询式的调度 表  SC2： SC2= SC1 + 时间保护。也就是说，当一个任务执行时间过长，它会被停止；SC2同时还定义了时间监控。防止因为一个任务时间过长而影响其他任务的实时性  SC3： SC3 = SC1 + 内存保护。针对未经授权访问安全相关软件组件的内存区域的防护  SC4： SC4 = SC1 + 时间保护 + 内存保护 = SC2 | SC3"},{"title":"Autosar实践基本操作","path":"2022/01/15/Autosar实践基本操作/","text":"AUTOSAR的基本架构 微控制器（Microcontroller）：即控制器硬件。 基础软件层（Basic Software Layer，BSW）:基础软件层，它包含了以下4个部分： 微控制器抽象层（Microcontroller Abstraction Layer，MCAL）：是与硬件直接相关的驱动软件，例如对存储器、通信寄存器、IO口的操作等等。 ECU抽象层（ECU Abstraction Layer，ECUAL）：是对控制器的基础功能和接口进行统一，比如CAN报文内容的解析、网关报文的转发、存储器读写流程的控制等等。 服务层（Services Layer）：为应用层提供各种后台服务，比如网络管理、存储器管理、总线通信管理服务以及操作系统等。 复杂设备驱动（Complex Device Drivers，CDD）：为用户提供了一个可以自行编写特殊设备驱动软件的可能性。 运行环境（Runtime Environment，RTE）：是AUTOSAR的核心，它将应用软件层与基础软件层剥离开来，为应用层软件提供运行环境，如进程时间片调度、应用层模块之间以及应用层与基础软件层之间的数据交换等。 应用软件层（Application Software Layer，ASW）：即实现具体应用功能的软件。它可以包含多个软件组件（Software Component，SWC）。 初识Autosar工具 我们目前用到的Autosar工具如下图所示： DaVinci Developer ：主要用来设计AppL的程序架构 DaVinci Configurator Pro：主要用来配置BSW和自动生成RTE的 在DaVinci Developer中配置Appl 1.打开DaVinci Configurator，点击File-&gt;new，出现如下界面，配置好后点击next 2.选择芯片和编译器 3.这里有默认的推荐路径，如需配置，可以按照下图有说明进行配置 这里工程会自己加载出来，一般不需要改变，若需变更参考下面说明 4.保存工程，打开DaVinci Developer 软件，点击File-&gt;Open Workspace，选中之前Cfg配置路径下的.dpa工程 在DaVinci Developer中配置Appl Service Component Types 这里的Service Component Types其实在这里一般不需要我们手动定义。因为在Configurator中，当我们配置BSW服务层模块的时候，这里就会根据我们的配置同步过来自动生成 Data Types 定义Data Types主要定义的是ApplicationData Types、Implementation Data Types和BaseTypes这三种： •ApplicationData Types（简称ADT）：大家理解成是在Developer软件的图形界面上使用的类型，只存在于软件中，不会在代码中体现 •ImplementationData Types（简称IDT）：理解成是对Base Types改了个名字，方便代码生成时阅读的，比如：typedef uint8Std_ReturnType •BaseTypes：就是我们经常用到的int、bool、uint16、float等这样的基础类型 •Units：就是数据的单位，比如km、h和kg等 •Compu Method：计算方法，比如我采样到的ADC是0 - 4095，那么如何转换成真实的电压值，可以在这里定义一个转换的计算方法。该计算方法可以是线性的，非线性的等等。这个计算方法会在代码中生成一个#defineData •Contraints：数据约束，就是对数据进行最大、最小值约束等操作 4.ApplicationData Types（命名规则参考附录），其它的类型类似 5.打开Davinci Configuratior工程，加载.dpa工程。在Davinci Configuratior中导入DBC 5.打开Developer工程，通过Interface创建SWC上的Port实体，按照步骤1所示，新建一个SWC，命名规则可参考附录：命名规则 查看Data Mapping，已经出现DBC中相关信号和信号组了。 7.完成后出现如提示的端口和SWC相连接 8.建立Runnable 8.配置Runnable的属性 8.保存Developer中的配置，并将Runnable添加至Configuratior的Task中。重新生成代码 附录-命名规则"},{"title":"Vector CANdb","path":"2022/01/12/Vector-CANdb/","text":"DBC文件 它被用来描述单一CAN网络中各逻辑节点信息，依据该文件可以开发出来监视和分析CAN网络中所有逻辑节点的运行状态，也可以是有针对性的ECU通信应用软件。 DBC是一种文件格式，.dbc文件是一个ASCII格式的文件，其.dbc扩展名可用于定义CAN网络 每辆汽车都关联着一个.dbc文件，即“数据库CAN”文件，每个品牌的车都有自己的.dbc文件且都是保密的。 DBC解析过程就是将汽车CAN网络传输的十六进制数据转换成我们所熟悉的物理量，比如车速，燃油量，发动机转速等 DBC制作过程2.1 建立DBC（1）打开“CANdb++”软件，点击其页面左上角的File选项卡，在其弹出的选项中，选择CresteDatabase选项，如图2-1所示；这一步建立了一个数据库，但是类型未定； 图2-1建立数据库 （2）在弹出的窗口选中“CANTemplate.dbc”选项，然后 点击左下角的“OK”，建立DBC完成，如图2-2所示；这一步指为新建的数据库定一个类型为CAN模板的DBC文件； 图2-2 定数据库类型为DBC （3）随后弹出一个New DatabaseFile的窗口，选择新建DBC的保存路径和名字。 这里需要注意的是，DBC文件的命名应该是包含项目，具体功能，更新日期等要素； 图2-3 选择文件保存路径和名字 2.2添加属性 添加属性有两种方法，第一种是手动添加属性，工作量较大；第二种是从别的DBC文件导入属性，相对而言较快，但是可能会缺失部分属性。下面将两种添加方法都一一介绍； 方法一：手动添加属性 （1）点击上方View选项卡，在弹出的选项中，点击“Attribute Definitions”选项，如图2-4所示； （2）在新窗口中任意空白处右键，弹出选项窗口，选择New选项；这一步是新建了一个属性，如图2-5所示； 图2-5 新建一个属性 （3）填写属性中define（定义）选项中名字，类型，数值类型，默认值，最小值和最大值、comment（描述）选项中对该属性所对应报文的描述，如图2-6所示；这些描述都可以在项目相关的报文资料中查找到； 图2-6 填写属性信息 方法二：导入属性 （1）点击左上角File选项卡，在弹出的选项中，选择“Import Attribute Definitions”，如图2-7所示； 图2-7 打开导入属性选项 （2）随后弹出一个“Import Attribute Definitions from”窗口，选择所想要导入的DBC文件，如图2-8所示； 2.3创建节点（Network notes） CAN总线连接各个网络节点，形成多主机控制器局域网（CAN），控制单元通过CAN 总线输入和输出信息，网络节点用来实现控制单元和CAN 总线的交互。一个节点的定义主要包括：节点名称，地址。 图2-9 节点说明图 节点创建方法： 如图，右击Network nodes，点击New创建一个节点如图2-10所示 （2）设置节点的信息： 在Defination界面，如图2-11，根据需求输入节点的Name和Address（一般选择默认地址即可）。 （3）在Attributes界面设置节点的属性（矩阵表中若无以下属性，就不做设置）设置完成后，点击“确定”： 图2-12 设置节点属性 2.4创建报文(Messages) Can报文从应用层来讲，是一种用于车身各个节点的通讯的协议，一条Can报文的定义主要包括： （1）发送节点； （2）接收节点 （存在多个接收节点）； （3）报文属性：报文类型及周期类型 等； （4）信号； 报文创建方法： （1）在Messages处右键 -&gt; New ，如图2-13所示： 图2-13 添加Messages （2）根据CAN矩阵表的信息填写报文名称、ID、DLC、Type、Transmiter（需要之前就添加了节点）、Tx Method、Cycle Time如图2-14所示： 每个报文名称对应一个ID，DLC说明了该报文的长度，以Byte为单位，Type分为CAN Standard和CAN Extended，说明了报文的格式，CAN协议支持两种报文格式，这两种格式唯一的不同是标识符（ID）的长度不同，标准格式CAN Standard的ID为11位，扩展格式CAN Extended为29位，我们一般选择CAN Standard。 图2-14 填写报文信息 （3）在Signals界面，根据CAN矩阵表添加这条报文所包含的信号（前提是将信号已经创建好）。如图2-15所示，点击Add，在Choose objects对话框根据不同的条件，点击Filter筛选信号，选中信号后点击OK，即可将这条信号添加到报文上。 图2-15 添加所属信号 （4）如图2-16所示，在Transmitters添加该报文所属的节点（发送节点）。Receivers对话框查看该报文的接收节点 。Layout表示该报文中所有信号的存放位置，如图2-17，具体会在信号创建章节讲到。 图2-16 添加发送节点 图2-17 查看信号所处位置 表2-1 报文常用属性及说明 Attribute Value 说明 GenMsgCycleTime 20 周期型时，报文的发送周期为20ms GenMsgIlSupport Yes 支持Gen工具生成代码 No 不支持Gen工具生成代码 GenMsgSendType Cyclic 周期型 NotUsed NoMsgSendType 无发送类型（报文传输行为将由信号决定） IfActive 事件型 报文类型与信号类型搭配具体说明： Ø 当报文中信号所有类型都是事件型：Onwrite / OnwriteWithRepetition /OnChange /OnChangewithRepetiton / IfAcitve /IfAcitvewithRepetiton /NoMsgSendType，报文中的类型即是NoMsgSendType 。 Ø 当报文中信号类型中存在 ：Cyclic；报文类型即是Cyclic； Ø 事件型信号跟周期型信号在同一条报文中无法兼容，代替事件型信号的有一种信号类型是周期事件型。 （4）最后，在所有都设置结束后，点击“应用-&gt;确定”。 2.5添加信号(Signals) （1）按照矩阵表里报文中的信号顺序添加，如下图2-19。在Signals下空白处右键New，按照矩阵表的信息填写信号名称(Name)，信号长度(Length [Bit])，字节顺序(Byte Order)，单位(Unit),数值类型(Value Type)，初始值(Init Value)，品质因数(Factor)，偏移量(Offset)，最小值(Mininum)，最大值(Maxinum)，字节顺序(Byte Order)有Motorola与Intel两种类型，具体的区别如下图2-20，一般我们使用的是Motorola的字节顺序格式。数值类型(Value Type)有Unsigned / Signed / IEEE Float / IEEE Double根据数据的具体类型来选择。当前从CAN报文得到信号的数值是未解析的数值(Raw Value)，需要经过数值处理后得到物理值，物理值可以便于我们进行数据分析，例如车速这个信号的数值是不能用未解析的十六进制数(Raw Value)来表示的，需要转换为物理值来进行数据的分析。转换关系为： Physical Value=(Raw Value*Factor)+Offect （2）一条CAN报文由一个或多个CAN信号组成，CAN信号才是各个节点信息交互的单位。一条报文中，不同的信号可能被不同的节点接收，也可能一个信号被多个节点接收。接下来就在一个信号中添加该信号是属于哪一条报文。如图2-21所示，在Messages对话框下点击Add，弹出图2-22对话框，可以根据报文名称或者报文ID等选择此信号所属的报文，点击保存。 图2-21 添加 图2-22 选择信号所属的报文 （3）修改报文里每个信号的起始字节位置。 方法一：鼠标选中相应的报文左键，在右边根据矩阵表的信息修改每个信号的起始位置，双击相应的信号，在新的对话框填写起始位置即可,如图2-23（a）。 方法二：双击需要修改的报文，选择Layout对话框，根据矩阵表上信号的起始位置，用鼠标拖动相应的信号到对应的位置。点击“确定”,如图2-23（b）。 图2-23 修改信号在报文中的起始位置（a） 图2-23 修改信号在报文中的具体位置（b） （4）信号的类型有 周期型：Cyclic 事件型：Onwrite / OnwriteWithPepetition /OnChange/OnChangewithRepetiton / IfAcitve/IfAcitvewithRepetiton / NoMsgSendType 报文类型与信号类型搭配，当报文中信号所有类型都是事件型：Onwrite / OnwriteWithRepetition / OnChange/OnChangewithRepetiton / IfAcitve /IfAcitvewithRepetiton / NoMsgSendType。报文中的类型即是NoMsgSendType； 当报文中信号类型中存在周期型：Cyclic，报文中的类型即是周期型Cyclic；修改信号的属性，如图2-24所示。Cyclic发送模式如图2-25所示，调用ILPutTx将数据复制到我们在信号的buffer中，等待Cycletime，通过Iltask发送出去。Ittask的周期通过geny配置。 图2-24 编辑信号属性 2.6节点、报文和信号三者之间关系 节点里面包含报文，报文里面包含信号。在DBC编辑中，节点能够添加发送的报文和接收的信号；报文能够添加信号及发送该报文的节点；信号只能添加所属的报文。 为了提高工作效率，节点、报文和信号应该先建立哪一个？ （1）在清楚的知道有哪些节点的情况下：建议先建立节点，再建立报文同时将报文添加到节点中，然后再建立信号同时将信号添加到报文里，最后就是为节点添加接收信号，报文的接收信号。 （2）在不清楚节点具体是什么情况时：建议先建立报文，然后再建立信号同时将信号添加到报文里，最后就是添加报文的接收信号等。 下面则分别是节点与报文；报文与信号建立链接的步骤。 2.6.1为节点添加所属的报文及所要接收的信号 （1）节点添加报文： -&gt; 选中在节点编辑窗口中的Tx Message 选项 -&gt;点击左下角的Add按钮 -&gt;在Filter by中选择查找方式（Name、ID等） -&gt;在弹出的对话框中的Value中输入报文的名字 -&gt;点击右边的Filter 按钮 -&gt;在下方的选择框中选择所需要的报文 上述步骤如图2-32所示： 图2-32(a) 节点添加报文的选项 图2-32(b) 选择查找方式 （2）节点添加接收信号： -&gt;在节点编辑窗口中Mapped Rx Sig选项点击左下角的Add按钮 -&gt;在Filter by中选择查找方式（Signal、Message等） -&gt;在Value中输入信号的名字 ，点击右边的Filter 按钮 -&gt;在下方的选择框中选择所需要的信号 上述步骤如图2-33所示： 图2-33(a) 节点添加信号的选项 图2-33(b) 选择信号的查找方式 2.6.2为报文添加所属的信号 （1）为报文添加信号 -&gt;在报文编辑窗口中的Signals选项点击左下角的Add按钮 -&gt;在Filter by中选择查找方式（Name等） -&gt;在Value中输入信号的名字 ，点击右边的Filter 按钮 -&gt;在下方的选择框中选择所需要的信号 2.7加信号值的描述 信号值的描述是指描述信号不同的值所代表的意义。在使用CANoe调试时，可以直接显示对应的值的描述（意义），不用再去查找CAN矩阵表，方便我们解读信号值的含义。 2.7.1添加信号值的描述的具体过程 （1）进入Value Table编辑窗口方法：点击菜单栏中的View -&gt; Value Table，如下图2-35所示： 图2-35 进入Value Table编辑窗口方法 （2）新建一个信号Value Table 描述：执行完上述一步后，会弹出Value Table编辑窗口。在窗口中的空白处右键 -&gt; New 。如下图2-36所示： 图2-36 新建一个信号Value Table 描述 （3）定义信号Value Table的描述名：在弹出的窗口中的Definition 选项中对这个信号的Value Table描述进行命名。如图2-37所示。 图2-37 定义信号Value Table的描述名 （4）编辑信号值的描述：在ValueDescriptions选项中，点击Add按钮，在新出现的那一行双击value中的“0x0”或者Description 中的“Description for the value ‘0x0’”，根据具体的信号的值和描述进行修改。如图2-38所示： 图2-38 编辑信号值的描述 （5）对已有的信号Value Table进行修改：在所要修改的Value Table上右击鼠标，在出现的下拉菜单栏中选择“Edit Value Table…”。之后与前面的步骤（3）、（4）同样的操作。 2.7.2给对应的信号添加Value Table 图2-42 信号添加value Table方法二 2.8 最后检查整个DBC有没有错误 点击File -&gt; Consistency Check 。根据错误解释对有错误的信号或者报文进行修改，如图2-60所示： 图2-43 全局检查错误 表2-2 错误类型与对应的原因 错误标识 错误原因 严重程度 蓝色感叹号 信号长度警告 较低 红色错误 该报文没有接收节点 低 黄色三角形红色感叹 1，报文内信号长度有重叠2.信号名称由重复 高 黄色三角形红色感叹+ 节点里信号被接收多次 较高"},{"title":"通信原理（66题）","path":"2022/01/10/通信原理（66题）/","text":"1 、 简要说明数字通信较之模拟通信的优缺点模拟通信，技术很成熟，就是将模拟信号与载波进行调制， 使其带有一定载波特性，又不失模拟信号的独特性， 接受端通过低通滤波器， 还原初始模拟信号。而数字通信，首先进行采样，对于采样幅值进行编码（ 0 ,1 编码 ），然后进行调制， 相移键控等。 接受端还原即可。 区别在于,由 于数字通信其传输数字抽样信号 ，在 接受端可以得到还原， 所以信号传输率高。 而模拟信号， 是对于信号的直接调制,与载波相乘，当 传输途中有干扰时， 对于系统的冲击， 是不可修复的,所以造成失真。相对 而言， 数字通信优于模拟通信。 与模拟通信相比， 数字通信的优势主要有： 抗干扰能力强， 数字信号可以再生而消除噪声积累； 传输差错可控, 能改善传输质量； 易于使用现代数字信号处理技术对数字信号进行处理； 易于加密，可靠性高； 易于实现各种信息的综台传输。 但数字通信的缺点是： 系统设备复杂， 对同步要求高， 比模拟通信占据更宽的系统频带等。 2 、 简述消息、信息、信号三个概念之间的联系与区别消息是包含具体内容的文字、 符号、 数据、 语音、 图片、 图象等等， 是信息的具体表现形式， 也是特定的信息。 信息是消息的统称， 是消息的概括和抽象， 可理解为消息中包含的有意义的内容， 它用信息量来衡量。 信号是搭载或反映信息的载体， 通常以某种客观物理量（ 电压、 电流） 表现出来。消息、 信息、 信号是与通信密切相关的三个概念。 信息一词在概念上与消息相似， 但其含义却更具普遍性、 抽象性。 消息可以有各种各样的形式， 但消息的内容可统一用信息来表述， 传输信息的多少可直观地使用” 信息量” 进行衡量。 信号是消息的载体和通信的客观对象， 而信息是信号的内涵。 3 、 简要回答香农公式的在通信系统中的重要意义？ 香农信道容量公式：香农公式是在一定的信号带宽限制下， 在一定的信噪比之下的数据最大传输速率。 揭示了信道对数据传输率的限制。 4 、 如何评价模拟通信系统和数字通信系统的有效性和可靠性？ ① 有效性： 指传输一定信息量时所占用的信道资源（ 频带宽度和时间间隔） ， 或者说是传输的” 速度” 问题。 ② 可靠性： 指接收信息的准确程度， 也就是传输的” 质量” 问题。 ③ 对于模拟通信系统： 有效性用带宽来衡量， 可靠性用信噪比来衡量。 ④ 对于数字通信系统： 有效性用传输速率或频带利用率来衡量， 可靠性用误码率、 误信率来衡量。模拟通信系统： 已调信号带宽越小， 有效性越好， 解调器输出信噪比越高， 可靠性越好。数字通信系统： 频带利用率越高， 有效性越好， 误码率越小， 可靠性越高。 5 、 什么是误码率， 什么是误信率， 它们之间关系如何？所谓误码率， 是指错误接收的码元数在传送总码元数中所占的比例， 或者更确切起的说， 误码率即是码元在传输系统中被传错的概率。 所谓误信率， 又称误比特率， 是指错误接收的信息量在传送信息总量中所占的比例， 或者更确切地说， 它是码元的信息量在传输系统中被丢失的概率。 二者之间的关系：它们都是用来表示差错率的。二进制系统中误码率与 误信率相等， 但在多进制系统中， 误码率与误倍率一般不相等， 通常误码率大于误信率。 6 、 何谓严平稳随机过程， 何谓广义平稳随机过程， 它们之间的关系如何？若一个随机过程 f(t) 的任意有限维分布函数与时间起点无关 ，则 称该随机过程是在严格意义下的平稳随机过程， 简称严平稳随机过程。 若一个随机过程 f(t) 的均值与 t 无关， 为常数 a， 自相关函数只与时间间隔有关， 则把同时满足上述两个条件的过程定义为广义平稳随机过程。 严平稳随机过程必定是广义平稳的， 反之不一定成立。 7 、 什么是码元速率？ 什么是信息速率？ 它们之间的关系如何？ 码元速率 RB 定义为每秒钟传送码元的数目， 单位为” 波特” ， 常用符号 “ B”表示，又称为码元传输速率或传码率。信息速率 Rb 定义为每秒钟传递的信息量， 单位是比特/ 秒（ bit/ s 或 bps） 。 设通信系统传送 N 进制码元， 则码元速率 RB 与信息速率 Rb 之间的关系 为 Rb= RBlog 2N* (bits*)或 RB= Rblog2 N(B) 8 、 什么叫抽样、 量化和编码？ 抽样 ： 将时间上连续的信号处理成时间上离散的信号； 量化： 对时间上离散的信号处理， 使其在幅度上也离散； 编码： 将量化后的信号样值幅度变换成对应的二进制数字信号码组的过程。 9 、 恒参和随参信道① 恒参信道： a. 常见类型： 明线， 对称电缆， 同轴电缆， 光纤信道， 无线电视中继， 卫星中继； b. 恒参信道对信号的影响： 幅频畸变， 相频畸变； c 信道不理想时会导致： 码间干扰； d. 解决方案： 均衡； ② 随参信道： a. 常见类型： 电离层信道， 对流层信道， 移动通信； b. 随参信道的特点：信道参数随时间变化， 损耗时变， 时延时变， 多径传播； c. 随参信道对信号的影响：瑞利型衰落， 多径传播引起的频率弥散， 频率选择性衰落 d. 解决方案： 分集； 10 、 简要回答均匀量化与非均匀量化的特点。均匀量化特点， 在量化区内， 大、 小信号的量化间隔相同， 最大量化误差均为半个量化级， 因而小信号时量化信噪比太小， 不能满足要求。 非均匀量化特点：量化级大小随信号大小而变，信号幅度小时量化级小， 量化误差也小； 信号幅度大时量化级大， 量化误差也大， 因此增大了小信号的量化信噪比。 11 、 PCM 通信能否完全消除量化误差？ 为什么？量化是用有限个值代替了无限个值， 用量化值和其所代表的样值之差来作为量化噪声， 该噪声只能通过增加量化级数， 即减小量化级长的方法来减弱， 但无法消除。 12 、 简述数字调制与模拟调制之间的异同点？ 多进制调制与二进制调制相比具有什么特点？数字调制与模拟调制就调制原理而言完全一样， 因为数字信号可以看作是模拟信号的特殊情况； 然而由于数字信号具有开关特性， 因此数字信号的调制可以利用其开关特性来实现， 即键控方式， 这样可以使调制实现起来简单。 多进制调制相比二进制调制在信息速率相同的情况下， 可以获得较高的频谱利用率， 进制数越高， 频谱利用率也就越高； 但抗干扰能力则较二进制有所下降， 且进制数越高， 抗干扰能力越差。 13 、 什么是复用方式？ 它有哪几种类型？ 各有何含义实现在同一条通信线路上传送多路信号的技术叫做多路复用技术。 各种多路复用技术的目的均在如何尽量提高信道的利用率。 目前常用的复用方式主要有频分复用、时分复用、码分复用和空分复用。频分复用(FDM) 是指根据工作频率来区分用户， 各路信号的频谱处于不同频段的物理信道上， 互不重叠。时分复用(TDM) 是指根据工作时隙来区分用户，它将整个信道传输信息的时间划分成若干时隙， 并将这些时隙分配给每一个用户使用， 每一路信号在分配给自己的时隙内独占信道进行数据传输。 码分复用(CDM) 是指根据码型来区分用户， 系统为每个用户分配各自特定的地址码， 地址码之间具有相互准正交性， 所有子信道在时间、 空间和频率上则可以重叠。 空分复用(SDM) 是指多对电线或光纤共用一条缆的空间复用方式。 14 、 均衡和分集① 均衡： 在基带系统中传入一种可调滤波器就可以补偿整个系统的幅频和相频特 征， 从而减小码间干扰的影响。 这个对系统校正的过程称为均衡， 实现均衡的滤波器称为均衡器。 均衡分为频域均衡和时域均衡。 频域均衡是从频率响应考虑， 使包括均衡器在内的整个系统的总传输函数满足无失真传输条件。 而时域均衡， 则是直接从时间响应考虑， 使包括均衡器在内的整个系统的冲激响应满足无码间串扰条件。 频域均衡在信道特性不变， 且传输低速率数据时是适用的， 而时域均衡可以根据信道特性的变化进行调整， 能够有效地减小码间串扰， 故在高速数据传输中得以广泛应用。 ② 分集： 分集类型： 时间分集， 空间分集， 角度分集， 极化分集， 频率分集等。在接收端的合并技术有： 选择方式； 最大比合并方式； 等增益合并方式等。 15 、 什么是多径效应？在随参信道当中进行信号的传输过程中， 由于多径传播的影响， 会使信号的包络产生起伏， 即衰落； 会使信号由单一频率变成窄带信号， 即频率弥散现象； 还会使信号的某些频率成分消失， 即频率选择性衰落。 这种由于多径传播对信号的影响称为多径效应。 16 、 什么是调制？ 调制在通信系统中的作用是什么？所谓调制， 是指按调制信号的变化规律去控制高频载波的某个参数的过程。作用是：将基带信号变换成适合在信道中传输的已调信号； 实现信道的多路复用； 改善系统抗噪声性能。 17 、 什么是奈奎斯特准则？ 什么是奈奎斯特速率？为了得到无码间串扰的传输特性， 系统传输函数不必须为矩形， 而容许具有缓慢下降边沿的任何形状， 只要此传输函数是实函数并且在 f=W 处奇对称， 称为奈奎斯特准则。 同时， 抽样速率 fs 应不小于 2fh， 这一最低抽样频率 2fh 称为奈奎斯特速率。 18 、 为什么绝大多数无线信道对信号的影响要比有线信道大？ 在无线通信系统中， 主要采用什么技术解决这种影响？ ① 大多数无线信道都属于随参信道，随参信道的特点：信道参数随时间变化， 损耗时变， 时延时变， 多径传播； ② 随参信道对信号的影响： 瑞利型衰落， 多径传播引起的频率弥散，频率选择性衰落； ③ 在无线通信系统中多采用分集技术。 19 、 简述眼图的产生过程？ 眼图的作用？ 眼图中衡量传输质量的指标？ （ 至少写出三个） ① 眼图产生：信号加在示波器的垂直输入端上，示波器水平扫描周期与码元同步的周期同步。 在示波器上就可以观测到眼图。 ② 眼图作用： 定性观测码间干扰和噪声对系统的影响。 ③ 衡量传输质量的指标（ 眼图参数）： 最佳判决门限， 最佳抽样时刻， 噪声容限， 定时误差灵敏度等。 20 、比较预加重去加重技术和压扩技术的异同？ FM 调制系统采用的是何种技术？ 为什么？ PSTN 中采用的是何种技术？ 为什么？ ① 预加重去加重技术和压扩技术相同点 ：改 善系统信噪比 ，提 高通信质量。 ② 预加重去加重技术和压扩技术区别 ：a. 预加重去加重技术改善高频信号的信噪比。 b. 压扩技术改善小信号信噪比。 ③ FM 调制系统中采用预加重去加重技术，原因是 FM 调制系统，解调器输出端的噪声呈平方率分布，高频分量受到的噪声影响大，低频分量受到的噪声影响小， 预加重去加重技术的目的就是为了提升高频信号的信噪比。 ④ PSTN 系统中的 PCM 编码时采用的是压扩技术。 使用压扩技术的原因是信号幅度的概率分布不均匀，所以采用压扩技术进行非均匀量化，PCM 中压扩技术目的是为了提升小信号的信噪比。 21 、 多进制数字调制系统和二进制数字调制系统的比较。 与二进制数字调制系统比较， 多进制调制系统具有以下两个特点：① 在相同的码元传输速率下，多进制系统的信息传输速率显然要比二进制系统的高。 ② 在相同的信息传输速率下，由于多进制码元传输速率比二进制的低，因而多进制信号的码元的持续时间要比二进制的长， 相应的带宽就窄。 22 、 用香农公式来解释调频方式与调幅方式性能上的优劣关系。香农公式表示在信道容量一定的情况下，信道带宽越宽（ 有效性下降）， 则要求信道提供的信噪比可以越小（ 可靠性提高）， 即可以提高抗干扰能力。对于调幅方式， 其占用的频带要比调频方式占用的频带小， 而抗干扰能力则要比调频方式的差， 这正好符合香农公式所反映的两者间关系 23 、 抽样后为什么要加保持电路？抽样后为防止相邻话路样值在公共通道上挨得太近会导致串音以及样值 脉冲顶部不平坦导致不能选取量化标准 。抽 样脉冲的宽度通常取得很小, 一般远小于一个时隙的宽度, 即 n 位码宽, 所以在抽样后编码前加保持电路, 将样值脉宽展宽为一个时隙宽度。 24 、 什么是信源编码？ 什么是信道编码？ 各自在通信系统中的作用？ 并列举几种常见的信源编码和信道编码？① 信源编码是为了减少信源输出符号序列中的冗余度、 提高符号的平均信息量而进行的编码。 信道编码是通过增加冗余比特从而实现差错控制而进行的编码。 ② 信源编码是为了提高通信系统的有效性。 信道编码是为了提高通信系统的可靠性。 ③ 信源编码是完成 A/ D 转换。 信道编码是将信源编码器输出的机内码转换成适合于在信道上传输的线路码， 完成码型变换。 常见信源编码： PCM， DPCM, DM, 霍夫曼编码等。常见信道编码： 线性分组码， 循环码， 卷积码， CRC， BHC。 25 、 简述为什么实际的数字调相不能采用绝对调相而采用相对调相？数字调相系统多采用直接法载波同步方式 ，因 此存在载波相位模糊现象。对于绝对调相的基带码元与载波相位间关系是固定的， 因此载波相位模糊使得解调出的基带信号出现不确定， 从而无法实现正常传输； 而相对调相是利用载波相位的变化来表示基带码元， 因此载波相位模糊不会影响载波相位的变化， 故对相对调相解调出的基带信号不会产生影响。 26 、 简述基带系统中选择线路码型的要求？ 基带系统中选择线路码型， 应具有如下特点： ① 无直流分量， 低频分量尽量少； ② 码型统计频谱越窄越好； ③ 便于从信号中提取定时信息； ④ 尽量提高传输码的传输效率； ⑤ 适用于信源的统计变化； ⑥ 编译码设备尽可能简单； 27 、 什么是部分响应波形， 什么是部分响应系统有控制的在某些码元的抽样时刻引入码间干扰，而在其余码元的抽样时 刻无码间干扰， 那么就能使频带利用率提高到理论上的最大值， 同时又可以降低对定时精度的要求， 通常把这种波形称为部分响应波形。 利用部分响应波形进行的基带传输系统称为部分响应系统。 28 、 增量调制中会产生哪两种噪声，分别是怎样形成的，如何改善？调制会产生两种噪声： 一般噪声和过载量化噪声， 前者是有在量化时抽样值与量化电平的误差产生的， 后者是由于台阶信号的变化速度赶不上模拟信号的变化速度造成的； 要改善前者可通过减小量化台阶， 改善后者可通过增大采样频率来实现。 29 、什么是” 倒π 现象”？ 为什么二进制移相键控信号会出现” 倒π 现象”？ 怎么解决？① 在数字调制系统中， 如果采用绝对移相方式， 由于发送端是以某一个相位作为基准的， 因而在接收端系统中也必须有这样一个固定基准相位作参考。 如果这个参考相位发生变化（ 0 相位变π相位或π相位变 0 相位） ， 则恢复的数字信息就会发生 0 变为 1 或 1 变为 0 ， 从而造成错误的恢复。 而实际通信时，参考基准相位的随机跳变是可能的，而且在通信过程中不易被发觉， 就会在接受端发生错误的恢复， 这种现象就称为” 倒π现象” 。 ② 因为二进制移相键控信号采用是绝对移相方式 ，所 以就可能出 现” 倒π现象” 。 ③ 解决方案就是采用相对相移方式， 即 2DPSK 调制方式。 30 、 构成 AMI 码和 HDB 3 码的规则是什么？ 它们各有什么优缺点？AMI 码是把 1 码变换为交替的正一负一， 0 码保持不变。 AMI 码的优点是无直流分量。 编译码电路简单， 具有内在的检错能力。 缺点是长连零导致定时信号难以提取。 HDB 3 码是改进式的 AMI 码， 1 码还是变换为交替的正一负一， 当出现 4 个或 4 个以上的 0 码时， 第四个 0 变换为与前一个非零符号用相同的极性的破坏符号， 用 V 表示。 但相邻 V 码的极性必须交替出现， 以确保编好的码中无直流分量。 若 V 码与前一个非零码的极性不同， 则将第一个四连 0 的第一个 0 更改为与 V 码相同极性的 B 码 。HD B 3 码保持了 AMI 码的优点外， 还减少了连零串的出现， 有利于定时信号的提取。 31 、 什么是移频键控？ 2FSK 信号的波形有什么特点。又称数字频率控制， 是数字通信中使用较早的一种调制方式， 基本原理是利用载波的频率变化来传递数字信息。2FSK 是用数字基带信号控制载波的频率变化，0 符号对应于载频ω 1 ，1 符号对应于载频ω 2 ， 而且ω 1 和ω 2 之间的改变是瞬间完成的。 32 、 简述带通型信号的抽样不易采用低通型抽样定理进行抽样的原因？带通型信号是指信号的带宽B&lt;l 的信号， 该信号若采用低通型抽样定 理进行抽样可以符合抽样要求，但将带来频谱利用不合理， 抽样速率较高的现象， 因此应采用带通型抽样定理进行抽样可以降低抽样速率。 33 、 在通信原理中采用差错控制的目的是什么？由于数字信号在传输过程中受到加性干扰的影响 ，使 信号码元波形变坏， 故传输到接收端后可能发生错误判决。 因此需要差错控制来解决加性干扰的影响。 34 、PCM 通信中发端抽样后和收端分路后各有一个 3. 4 KHZ 的低通波波器， 这两者作用各有什么不同？发端滤波器的作用是： 限制输入信号的最高频率， 以免抽样电路对该信号抽样时不满足抽样定理而产生折迭噪声， 收端滤波器的作用是： 从 PAM 信号中检出包络线， 即取出原始信号的波形（ 低频分量） ， 实现原始模拟信号的还原。 35 、 一个 采用 非 相干 解 调方 式的 数 字通 信 系统 是否 必 须有 载 波同 步和 位 同步？ 其同步性能的好坏对通信系统的性能有何影响？ 采用非相干解调方式的数字通信系统可以不需要载波同步， 但必须有位同步。 位同步的性能好坏将直接影响到抽样判决的结果， 最终影响系统的误码率的大小。 36 、 说明码率、 码重何码距的概念码率就是数据传输时单位时间传送的数据位数， 一般我们用的单位是kbps。码重 W 就是码字中所含码元” 1 “的数目. 两个码组对应位上数字的不同位的个数称为码组的距离， 简称码距， 又称海明（ Hamming） 距离。 37 、 未来通信技术的发展趋势如何？ 未来通信技术主要以数字通信为发展方向。 随着光纤通信的不断发展， 有线通信将以光纤通信为发展方向， 当前主要研究单模长波长光纤通信、 大容量数宇传输技术和相干光通信。 卫星通信集中体现在调制／ 解调、 纠错编码／ 译码、 数字信号处理、 通信专用超大规模集成电路、 固态功放和低噪声接收、 小口径低旁瓣天线等多项新技术的发展。 移动通信的发展方向是数字化、 微型化和标准化。 38 、 简述无码间干扰条件的含义？把从波形形成输入到接收滤波器输出的传递函数 H( ω ) 的幅频特性在ω 轴上以 2 π /Ts 为间隔切开， 然后分段沿ω 轴平移到(- π /Ts， π /Ts) 区内将它们叠加起来， 其结果应当为一固定值 Ts， 即叠加后的结果为理想低通特性就可以做到在抽样点上无码间干扰。 39 、 试说明数字相位调制可以采用数字调幅的方式来实现的道理？ 数字相位调制的数学表示为 显然 、 由调制信号确定， 由此可见原来载波相位受调制信号控制的调 相变成了幅度受调制信号控制的正交调幅。 即数字调相可以用正交调幅来实现。 40 、 什么是窄高斯噪声？ 他在波形上有什么特点？ 它的包络和相位各服从什么概率分布？窄带高斯噪声： 若一个高斯噪声满足窄带条件， 即其带宽远远小于中心频率， 而且中心频率偏离零频很远， 则称之为窄带高斯噪声。 其波形上的特点是包络和相位都像一个缓慢变化的正弦波。 其包络的一维分布服从瑞利分布， 其相位的一维分布服从均匀分布。 41 、 单工， 半双工及全双工通信方式是按什么标准分类的？按照消息传递的方向与时间关系分类。 单工通信是指消息只能单向传输的工作方式， 通信双方只有一个进行发送， 另一个只能接受， 如广播， 无线寻呼等。 半双工通信指通信双方都能进行收发信息， 但是不能同时进行收发的工作方式， 如对讲机。 全双工通信是指通信双方能同时进行收发消息的工作方式， 如电话等。 42 、 什么是快衰落， 什是慢衰落？由多径效应引起的衰落称为快衰落； 由信号路径上由于季节， 日夜， 天气等变化引起的信号衰落称为慢衰落。 43 、 无码间串扰时， 基带传输系统的误码率与哪些因素有关？ 如何降低系统的误码率？无码间串扰时， 基带传输系统的误码率与抽样判决时的信噪比有关。 要降低系统的误码率需要提高抽样判决时的信噪比， 可以降低信道噪声或者提高信号平均功率。 44 、 什么是码间串扰， 怎样产生的， 对通信质量有什么影响码间串扰是由于系统传输总特性不理想， 导致前后码元的波形畸变、 展宽， 并使前面波形出现很长的拖尾， 漫延到当前码元的抽样时刻上， 从而对当前码元的判决造成干扰。 码间串扰严重时， 会造成错误判决。 45 、 为什么要抑制载波？在 AM 信号中， 载波分量并不携带信息， 仍占据大部分功率。如果抑制载波分量的传送， 就能够提高功率效率， 这就抑制载波双边带调制。 46 、 数字调制方式各自的优缺点：数字调制有： 幅移键控 ask （ 特点： 设备简单， 频带利用率高， 抗噪声性能差） ， 频移键控 fsk （ 抗干扰能力强， 占用频带较宽） ， 相移键控 psk（ 效率高） 。 47 、 DSB 调制系统和 SSB 调制系统的抗噪声性能是否相同， 为什么相同。 如果解调器的输入噪声功率密度相同， 输入信号功率也相同， 则单边带和双边带在解调器输出的信噪比是相等的。 48 、 数字调制的基本方式有哪些？ 其时间波形上各有什么特点？数字调制技术有两种方法： 一是利用模拟调制方法去实现数字式调制， 即把数字调制看成是模拟调制的一个特例， 把数字基带信号当成模拟信号的特殊情况处理。 二是利用数字信号的离散取值的特点通过开关键控载波， 从而实现数字调制， 这种调制方式通常有幅度键控、 频率键控和相位键控。 其时间波形上来说， 有可能是不连续的。 49 、 数字基带信号有哪些常见的形式？ 各有什么特点？ 它们的时域表达式如何？数字基带信号的常见形式有： 单极性波形， 双极性波形， 单极性归零波形， 双极性归零波形， 差分波形和多电平波形。 单极性波形用正电平和零电平分别对应二进制码” 1 “ 和” 0 “ ， 其波形特点是电脉冲之间无间隔，极性单一， 易用于 TTL, CMOS 电路， 缺点是有直流分量， 只使用于近距离传输。 双极性波形用正负电平的脉冲表示二进制 1 和 0 ， 其波形特点是正负电平幅度相等， 极性相反， 故 1 和 0 等概率出现时无直流分量， 有利于在信道中传输， 并且在接收端恢复信号的判决电平为零， 不受信道特性变化影响， 抗干扰能力强。 单极性归零波形电脉冲宽度小于码元宽度， 信号电压在一个码元终止时刻前总要回到零电平。 从单极性归零波形中可以直接提取定时信息。 双极性归零波形兼有双极性和归零波形的特点。 相邻脉冲之间存在零电位间隔， 接收端易识别码元起止时刻， 从而使收发双方保持正确的位同步。差分波形用相邻码元的电平跳变来表示消息代码， 而与码元本身的电位或极性无关。 用差分波形传送代码可以消除设备初始状态的影响， 特别是在相位调制系统中可以解决载波相位模糊的问题。 多电平波形的一个脉冲对应多个二进制码， 在波特率相同的情况下， 可以提高信息传输速率。 50 、 什么是门限效应？ AM 包络检波法为什么会产生门限效应？小信噪比时， 解调输出信号无法与噪声分开， 有用信号” 淹没” 在噪声之中， 这时候输出信噪比不是按比例地随输入信噪比下降， 而是急剧恶化， 这种现象称为门限效应。由于包络检波法的非线性作用，所以 AM 信号会产生门限效应。 51 、 什 么是 频域 均 衡？ 什 么是 时域 均 衡？ 横 向滤 波器 为 什么 能 实现 时域 均衡？ 频域均衡： 利用可调滤波器的频率特性补偿基带系统的频率特性， 使得包括可调滤波器在内的基带系统总的传输特性满足无码间串扰传输的要求。 起频率特性补偿作用的可调滤波器叫频域均衡器。 时域均衡器： 在接受滤波器后插入一个称为横向滤波器的可调滤波器， 这个横向滤波器可以将输入端在抽样时刻上有码间干扰的响应波形变换为在 抽样上无码间干扰的响应波形。 由于横向滤波器的均衡原理是在时域响应波形上的， 所以称这种均衡为时域均衡。 横向滤波器可以将输入端在抽样时刻上有码间干扰的响应波形变换成在 抽样时刻上无码间干扰的响应波形， 所以横向滤波器可以实现时域均衡。d 52 、 VSB 滤波器的传输特性应满足什么条件？ 为什么？残留边带滤波器的特性 H（ w） 在正负 Wc 处必须具有互补对称性， 相干解调时才能无失真的从残留边带中恢复所需要的调制信号。 53 、 试对 AM 和 DSB 可否采用包络检波方式进行解调进行讨论？AM 已调信号波形的包络即为调制信号， 采用包络检波的方式获得 AM 的包络线即恢复出原始信号； DSB 已调信号波形的包络与调制信号的波形不一样， 因此采用包络检波的方式所获得的 DSB 包络线不是已调信号波形， 无法恢复出原始信号 54 、 部分响应系统的优点是什么呢？ 缺点是什么？ （ 或采用部分响应技术会得到什么好处？ 需要付出什么代价？ ）优点： 频带利用率高， 在理论上可达到 2Bd/ Hz； 时域衰减快， 可以放宽对定时信号相位抖动的要求， 系统的频率特性不是理想矩形， 易于实现 缺点： 抗噪声能力比非部分响应系统差。 55 、 如何由白噪声得到窄带白噪声， 窄带白噪声的功率与其同相分量的功率及正交分量的功率有何关系：将白噪声通过窄带带通滤波器， 就可以得到窄带白噪声， 窄带白噪声的功率与其同相分量的功率以及正交分量的功率是相同的。 56 、 为什么 PCM 编码要用对数量化？ A 律和 u 律 PCM 量化特性为什么要用折线代替对数特性？对数量化可达到” 小信号量阶小， 大信号量阶大” 的要求， 改善小信号时的量化信噪比， 扩大对输入信号的允许动态范围。 用折线代替对数特性是为了能用数字电路来实现。 57 、 窄带高斯白噪声中的” 窄带” 、” 高斯” 、” 白” 的含义各是什么？窄带的含义是： 频带宽度 B 远小于中心频率 fc， 中心频率 fc 远离零频； 高斯的含义是噪声的瞬时值服从正态分布； 白的含义是噪声的功率谱密度在通带范围内是平坦的， 且是一个常数。 58 、 什么是频移键控？ 2FSK 信号产生和解调方法有哪些？频移键控是指用不同的载频来表示所传送的数字信息。（ 1 ） 利用矩形脉冲序列对一个载波进行调频产生；（ 2 ）利用受矩形脉冲序列控制的开关电路对两个不同的频率进行选通， 即键控法。 FSK 的解调通常采用非相干解调和相干解调两种方法， 同时还有鉴频法， 过零检测法和差分检波法。 59 、 对于抑制载波的双边带信号， 试简述采用插入导频法和直接法实现载波同步各有何优缺点？插入导频法： 插入导频法需要在发送端加导频插入电路， 在接收段需加导频提取电路。 直接法： 是从接收到的已调信号中提取载波， 由于 DSB 信号其功率谱中不含有载波分量， 必须加一非线性电路， 然后再提取。 相比较而言， 直接法无需在发送端增加任何电路， 因此直接法较插入导频法容易实现且对信号传输的影响要小。 60 、 解释最佳基带传输系统的含义？ 在理想信道下的最佳基带传输系统的结构具有什么特点？ 最佳基带传输系统的含义是消除码间干扰且抗噪声性能最理想的系统； 在理想信道符合恒参信道且传输特性不会带来频率失真， 因此不用考虑码间干扰， 此时基带传输系统的结构为接收滤波器的特性与信号特性共轭匹配。 61 、 简述连贯式插入法帧同步的基本方法？连贯式插入法是在每帧的开头集中插入帧同步码组的方法， 接收端只要检测出帧同步码的位置， 就可识别出帧的开头， 从而确定各路码组的位置获得收发间的帧同步。 62 、 在设计数字通信接收机输入端带通滤波器的频率特性时， 应考虑哪些因素？ （ 至少给出两个因素并说明它们与频率特性的关系）数字通信接收机输入端带通滤波器的带宽应尽量小， 以尽可能多地滤除信道噪声， 提高带通滤波器输出信噪比， 减小误码率； 另外整个通信系统的频率特性应满足无码间串扰的要求， 而通信系统的频率特性与接收机输入端带通滤波器的频率特性有关， 所以设计此带通滤波器时应满足无码间串扰的条件下， 尽量减小滤波器的带宽。 63 、 2DPSK 差分解调和相干解调相比其噪声性能哪种方法好， 为什么？相干解调比差分相干解调噪声性能好， 因为它的本地载波包含的噪声小， 而后者是用前一码元的波形来代替本地载波， 包含了信道噪声。 64 、 有哪几种同步信号？ 在何处？ 有何要求？有四种同步信号。 一是载波同步， 在相干解调时， 要求载波同步信号要与发送信号同频同相。 二是码元同步， 在抽样判决处， 要求同步信息频率与码元速率相同的定时脉冲。 三是群同步， 获取每帧的起止标志， 以便对接收码元能正确分组。 四是网同步， 是使通信网中各站点时钟保持同步。 65 、 什么是群同步法？ 群同步有哪几种方法？为了使接收码元能够正确分组。 又叫帧同步。 群同步方法有三种。 一是起止同步法， 二是分散插入法， 三是集中插入法。 起止同步法是在每帧数据的开头集中插入群同步码组。 集中插入法是寻找一组在信息码中很少出现的特殊码组， 将同步码插在信息码前面， 常用巴克码。 分散插入法是将同步码等间隔得插在信息码中。 66 、 为什么会产生相位模糊问题这是由于平方后产生的载波频率是原始载波频率的两倍，故需要使用二分 频电路， 由于分频起点的不确定性， 导致了相位模糊。"},{"title":"通信原理","path":"2022/01/10/通信原理/","text":"第一章消息和信息有什么区别？信息和信号有何区别 答：语音，文字，图形，图像等都是消息，信息则是消息中包含有意义的内容，或者说有效 内容， 信息必须转换为电信号， 才能在通信系统中传输，所以，信号是消息的载体。 什么是模拟信号？什么是数字信号？ 答：在时间上和幅值上均是连续的信号称为模拟信号，在时间和幅值都离散的信号称为数字 信号。 数字通信有何优点？ 答：（1）由于数字信号的可能取值数目有限，所以在失真没有超过给定值的条件下，不影响接收端的正确判决。此外，在有多次转发的线路中，每个中继站都可以对有失真的接收信加以整形， 消除沿途线路中波形误差的积累，从而使经过远距离传输后，在接收端仍能得到高质量的接收信号。（2）在数字通信系统中，可以采用纠错编码等差错控制技术， 从而大大提高系统的抗干扰性。 （3）可以采用保密性极高的数字加密技术， 从而大大提高系统的保密度。 （4）可以综合 传输各种模拟和数字输入消息，包括语音、文字、图像、信令等；并 且便于存储和处理（包括编码、变换等） 。（5）数字通信设备和模拟通信设备相比设计和制造更容易，体积更小，重量更轻。（6）数字信号可以通过信源编码进行压缩， 以减少多余度，提高信道利用率。（7）在模拟调制系统中，例如调频，接收端输出信噪比仅和带宽成正比的增长； 而在数字调制系统中， 例如脉冲编码调制， 输出信噪比随带宽按指数规律增长。 信息量的定义是什么？信息量的单位是什么？ 答：I=-logaP（x）；信息量的单位为比特（Bit) 按照占用频带分，信号可以分为哪几种？ 答：基带信号和带通信号 信源编码的目的是什么？信道编码的目的是什么？ 答：信源编码用以减少数字信号的冗余度，提高数字信号的有效性；如果是模拟信源（如话 筒） ，则它还包括 A/D 转换功能，把模拟输入信号转变成数字信号。 在某些系统中， 信源编码还包含加密功能， 即在压缩后还进行保密编码。信道编码的目的是提高信号传输的可靠性。它在经过信源编码的信号中增加一些多余的字符，以求自动发现或纠正传输中发生 的错误。 答：调制包含调节和调整的含义。调制的主要目的是使经过编码的信号特性与信道的特性相 适应， 使信号经过调制后能够顺利通过信道传输。另一目的是为了把来自多个独立信号源的信号合并在一起经过同一信道传输， 也采用调制的方法区分各个信号。 可以利用调制来划分各路信号，解决多路信号复用问题。 数字通信系统有那些性能指标？ 答：传输速率（码元速率，信息速率，消息速率）错误率（误码率，误比特率，误字率）频 带利用率 能量利用率 信道有哪些传输特性？ 答：噪声特性、频率特性、线性特性和时变特性等。 无线信道和有线信道的种类有哪些？ 答：无线信道的种类：视线传播、地波、天波。 有线信道的种类：明线、对称电缆和同轴电缆。 信道的模型有哪几种？ 答：调制信道模型和编码信道模型 什么是调制信道？什么是编码信道？ 答：把发送端调制器输出端至接收端解调器输入端之间的部分称为信道，其中可能包括放大 器、变频器和天线等装置；在通信网中，由于有多个发送端和接收端， 还会有交换设备。 在研究各种调制制度的性能时使用这种定义是很方便的。所以，它也称为调制信道。此外， 在讨论数字通信系统中的信道编码和解码时， 我们把编码器输出端至解码器输入端之间的部分称为编码信道。 何谓多径效应？ 答：（1）信号的传输衰减随时间而变； （2）信号的传输时延随时间而变；（3）信号经过几条路径到达接收端，而且每条路径的长度（时延）和衰减都随时间而变，即存在多径传播 现象。 电磁波有哪几种传播方式？ 答：视线传播 地波传播 天波传播 答：1.31 μm 和 1.5 μm 什么是快衰落？什么是慢衰落？ 答：多径传播使包络产生的起伏虽然比信号的周期缓慢，但是其周期仍然可能是在秒的数量 级。 故通常将由多径效应引起的衰落称为快衰落。这种衰落的起伏周期可能以若干天或若干小时计，故这种衰落为慢衰落。 信道中的噪声有哪几种？ 答：按来源分，人为噪声，自然噪声；按性质分，脉冲噪声，窄带噪声，起伏噪声。 热噪声是如何产生的？ 答：热噪声来自一切电阻性元器件中电子的热运动。 第二章何谓确知信号?何谓随机信号？答：确知信号是其取值在任何时间都是确定的和可预知的信号。 随机信号是指其取值不确定、且不能事先预知的信号。 试分别说明能量信号和功率信号的特性。答：能量信号：其能量等于一个有限正值，但平均功率为 0； 功率信号：其平均功率等于一个有限正值，但能量为无穷大。 试用语言(文字)描述单位冲激函数的定义。答：单位冲激函数可以看做一个高度为无穷大、宽度为无穷小、面积为 1 的脉冲。 试画出单位阶跃函数的曲线。答：从 0 时刻开始值为 1 的函数。 试述信号的四种频率特性分别适用于何种信号？答：信号的四种频率特性是：频谱函数、功率谱密度、频谱密度和能量谱密度，前两者适用 于功率信号，后两者适用于能量信号。 频谱密度和频谱的量纲分别是什么?答：频谱密度是伏特每赫兹（V/Hz），频谱的是伏特(V)。 随机变量的分布函数和概率密度有什么关系?答：概率密度是分布函数的导数。 随机过程的功率谱密度和自相关函数有什么关系?答：傅里叶变换的关系 随机变量的数字特征主要有哪几个?答：数学期望、方差、矩。 正态分布公式中的常数 a 和σ²有何意义?答：均值和方差 何谓平稳随机过程? 广义平稳随机过程和严格平稳随机过程有何区别?答：若一个随机过程的数字特征与时间起点无关，则称为广义平稳随机过程； 若一个随机过程的统计特性与时间起点无关，则称为严格广义平稳随机过程。 何谓窄带平稳随机过程?答：若信号或噪声的带宽和其载波或中心频率相比很窄，则称其为窄带随机过程。 一个均值为 0 的窄带平稳高斯过程的功率与它的两个正交分量 Xs(t)和 Xc(t) 的功率有何关系?答：其二者也是均值为 0 的窄带平稳高斯过程，且其三者方差相同。 何谓白噪声? 其频谱和自相关函数有何特点?答：由于在一般的通信系统频率范围内热噪声的频谱是均匀分布的，就像白光的频谱在可见 光的频谱范围内分布那样，所以热噪声又常称为白噪声。白噪声的自相关函数可以从他的功 率谱密度获得，因为功率谱密度的逆傅里叶变换就是自相关函数。 什么是高斯噪声?高斯噪声是否都是白噪声?答：高斯白噪声：如果一个噪声，它的幅度分布服从高斯分布，而它的功率谱密度又是均匀 分布；热噪声、散弹噪声和量子噪声都是高斯噪声。 自相关函数有哪些性质?答：R（o）是平稳随机过程 X（t）的平均归一化功率 Pn； 平稳随机过程的自相关函数是偶函数； 平稳随机过程的自相关函数是 R（T）绝对值的上界。 何谓随机过程的各态历经性?答：表示一个平稳随机过程的一个实现能够经历此过程的所有状态。 试用语言表述什么是线性系统。答：线性系统指一对输入端和一对输出端的线性网络，这个网络是无源的、无记忆的、非时 变的和有因果关系的。 冲激响应的定义是什么?冲激响应的傅里叶变换 等于什么?答：以单位冲激信号做激励，系统产生的零状态响应即为单位冲激响应。其傅里叶变换为 1。 如何用冲激响应描述线性系统的输出?答：时域分析法与频域分析法 何谓物理可实现系统，它应该具有什么性质?答：满足因果关系的系统称为物理可实现系统，具有性质在输入冲激脉冲前不应有输出冲激 响应，并且冲激响应的能量应该是有限的。 如何在频域中描述线性系统输入和输出的关系?答：输入的傅里叶变换乘以系统函数的傅里叶变换得输出的傅里叶变换。 信号无失真传输的条件是什么?答：无失真传输要求线性系统传输函数的振幅特性与频率无关，是一条水平直线，要求其相 位特性是一条通过原点的直线。 为什么常用时间延迟的变化表示线性系统的相位 失真?答：在实际应用中，由于相位特性很难测量，所以常用测量传输时延 td 的办法代替测量相 位，来均衡系统的传输失真。 随机过程通过线性系统时，系统输出功率谱密度 和输入功率谱密度之间什么关系?答：系统输出功率谱密度等于输入功率谱密度乘以 H（f）的绝对值的平方。 第三章调制的目的？答：第一，通过调制可以把基带调制信号的频谱搬移到载波频率附近。这就是将基带信号变 为带通信号。选择需要的载波频率，就可以将信号的频谱搬移到希望的频段。 第二，通过调制可以提高信号通过信道传输时的抗干扰能力。 模拟调制可以分为哪几类？答：线性调制和非线性调制 线性调制有哪几种？答：调幅信号 单边带信号 双边带信号 残留边带信号 非线性调制有哪几种？答：调频信号和调相信号 振幅调制和双边带调制的区别何在？两者的已调信号的带宽是否相等？答：（1）振幅调制信号包含直流分量，双边带调制的信号不包含直流分量。（2）相等 双边带语音信号的带宽是否等于单边带语音信号带宽的两倍？答：是 对产生残留边带信号的滤波器特性有何要求？答：滤波器的截至特性对于载波频率 f0 具有互补的对称性就可以了。 残留边带调制特别适用于哪种基带信号？答：适合于包含直流分量和很低频率分量的基带信号。 试写出频率调制和相位调制信号的表达式？ 什么是频率调制的调制指数？答：调制信号可能产生的最大相位偏移。 试写出频率调制信号的带宽近似表达式？ 试述角度调制的主要优点？答：角度调制信号的振幅并不包含调制信号的信息，所以不会因信号振幅的改变而使信息受 到损失。信道中的衰落及噪声对于信号的角度的影响与振幅受到的影响相比要小的多，以角 度调制信号的抗干扰能力强。 第四章模拟信号经过抽样后，是否成为取值离散的信号了？ 答：不是，还是模拟信号，因为此抽样值仍然是一个取值连续的变量。 对于低通模拟信号而言，为了能无失真的恢复，抽样频率和其带宽有什么关 系？ 答：fs≥2B 何谓奈奎斯特抽样速率和奈奎斯特抽样间隔？ 答：最低的抽样频率 2Fh 称为奈奎斯特抽样速率，与此相应的最大的抽样时间间隔 1/2Fh 称为奈奎斯特抽样间隔。 发生频率混叠的原因是什么？ 答：抽样频率低于奈奎斯特抽样速率。 PCM 语音通信通常的标准抽样频率等于多少？ 答：8000HZ 信号量化的目的是什么？ 答：使抽样信号数字化 非均匀量化有什么优点？ 答：改善抽样信号中的小信号的量噪比。 在 A 压缩律特性中，若选用 A=1，将得到什么压缩效果？ 答：无压缩效果 在 μ压缩律特性中，若选用 μ=0，将得到什么压缩效果？ 答：无压缩效果 我国采用的语音量化标准，是符合 A 律还是 μ律？ 答：A 律 在 PCM 系统中，为什么常用折叠码进行编码？ 答：折叠码的优点是误码对于小电压的影响较小。由于语音信号的小电压出现的概率较大， 所以折叠码有利于减小语音信号的平均量化 噪声。 何谓信号量噪比？有无办法消除它？ 答：信号功率与量化噪声功率之比为信号量噪比。无 在 PCM 系统中，信号的量噪比和信号带宽有什么关系？ 答：呈指数规律增长 ＤＰＣＭ和增量调制之间有什么关系？ 答：增量调制 DM 可以看成是一种最简单的 DPCM 。当 DPCM 系统中的量化电平数取 2， 且预测器仍简单地是一个延迟时间为抽样时间间隔 T 的延时线时，此 DPCM 系统称为增量调制系统。 第五章何为 ASCII 码？它用几个比特表示一个字符？试写出 ASCII 码 中字符” A”和” a”的码组。 答：ASCII 码使用指定的 7 位或 8 位二进制数组合来表示 128 或 256种可能的字符。 8 比特表示一个字符。” A”的码组为 1000001”a”的码组为 1100001. 试述双极性波形的优缺点。 答：优点：（1）单极性波形有直流分量，在许多不能通过直流电流的通信线路中不能传输。 而双极性波形，当数字信号中的 “0”和”1” 以等概率出现时，没有直流分量。 （2）双极性波形节省能源。（3）在接收端对每个接收码元做判决时， 对于单极性波形， 判决门限一般 应设定在 V/2,即在判决时刻若电平高于 V/2 就判为接收到” 1”（或”0”），低于 V/2 就判为接收到” 0”（或” 1”）。缺点：由于接收信号电平 V 是不稳定的，所以对设定判决门限造成困难。 试述 HDB3 码的编码规则及其优缺点。 答: 编码规则: HDB3 为一种双极性码，0 用”无极性”电平表示，1 交替用”正极性”和”负极性”电平表示;连续 4 个 0，第 4 个 0 变为极性 V 码，V 码极性交替;若无法保证极性相同，则第 1 个 0 变换成极性 B 码。优点:有丰富的位定时信息;缺点:实现略复杂。 试述双向码的优缺点。 答:优点:位定时信息易提取，0-1 等概率时无直流分量。缺点:带宽较宽。 随机脉冲信号序列的功率谱中的连续谱和离散谱分别有什么特点？离散谱有什么特殊的功用？何种信号中没有离散谱？ 答：（1）信号中离散谱分量的波形具有周期性，其中包含有码元定时信息，它可以用于在接收端建立码元同步。对于没有离散谱分量的信号，在接收端则需要对其进行某种变换，使其谱中含有离散分量，才能从中提取码元。（2）双极性信号 g(t)=-g(t), 且概率 P=1/2 时， 没有离散谱分量。 何谓码间串扰？它产生的原因是什么？是否只在相邻的两个码 元之间才有码间串扰？ 答：（1）由于系统传输特性影响，可能使相邻码元的脉冲波形互相重叠，从而影响正确判决。这种相邻码元间的互相重叠称为码间串扰。（2）原因是系统总传输特性 H（f）不良（ 3） 是 基带传输系统的传输函数满足什么条件时不会引起码间串扰？ 答：为得到无码间串扰的传输特性，系统传输函数不必须为矩形，而容许是具有缓慢下降边 沿的任何形状，只要此传输函数是实函数并且在 f=W 处奇对称。 何谓奈奎斯特准则？ 何谓奈奎斯特速率？ 答：只要此传输函数是实函数并且在 f=W 处奇对称，这称为奈奎斯特准则。 2Baud/Hz 是最高可能达到的单位带宽速率，并称为奈奎斯特速率。 何谓滚降？为什么在设计时常常采用滚降特性？ 答：（1）由于这时滤波器的边沿缓慢下降， 通常称之为滚降。（2）具有滚降特性的滤波特性仍能保持每秒 2W 码元的传输速率，但是它占用的带宽增大了，因此频带利用率有所降低。 何谓部分响应波形？他有什么优缺点？ 答：人为地，有规律地在码元抽样时刻引入码间串扰，并在接收端加以消除，从而可以达到 改善频谱特性，压缩传输频带，使频带利用率提高到理论上的最大值，并加速传输波形尾巴 的衰减和降低对定时精度要求目的，将这这种波形称为部分响应波形。 优点：频带利用率高，在理论上可达到 2Bd/Hz；时域衰减快，可以放宽对定时信号相位抖动的要求，系统的频率特性不是理想矩形，易于实现。 缺点：抗噪声能力比非部分响应系统差。 何谓双二进制波形？它和部分响应波形有什么关系？ 答：用双极性编码的二进制波形称为双二进制波形。第 I 类部分响应波形采用的是双二进制波形。 哪种部分响应波形中不含直流分量？ 答：第四类和第五类 何谓眼图？它有什么功用？在示波器的X 和 Y 轴上加入什么 电压才能观看眼图？ 答：眼图就是用示波器实际观察接收信号质量的方法。眼图可以显示传输系统性能缺陷对于 基带数字信号的传输影响。在示波器的垂直（Y）轴上加入接收信号码元序列电压，在水平 （Ｘ）轴上加入一个锯齿波，其频率等于信号码元的传输速率，即示波器水平时间轴的长 度等于信号码元的持续时间。 克服码间串扰的方法是什么？能否用增大信噪比的方法克服码间串扰？为什么？ 答：克服码间串扰的方法是在接收端插入一个均衡器。增大信噪比的方法无助于克服码间串 扰。因为在信道无噪声的情况下码间串扰依然可能存在。 何谓均衡器？ 为什么常用横向滤波器作为均衡器， 而不用由电感和电容组成的滤波器？ 答：（1）为了减少码间串扰，通常需要在系统中插入另一种滤波器来补偿，这种滤波器称 为均衡器。（2）横向滤波器很容易做成特性可调的，因此它常用来作为均衡器使用。 第六章何谓带通调制？带通调制的目的是什么？ 答：带通调制通常需要一个正弦波作为载波，把基带数字信号调制到这个载波上，是这个载 波的一个或几个参量（振幅，频率，相位）上载有基带数字信号的信息。目的是使已调信号 的频谱位置适合在给定的带通信道中传输。 何谓线性调制？何谓非线性调制？ 答： 线性调制的已调信号频谱结构和原基带信号的频谱结构基本相同，主要是所占用的频率位置搬移了。 非线性调制的已调信号频谱结构和原基带信号的频谱结构就完全不同了， 已不仅仅是简单的频谱平移，在已调信号频谱中通常会出现许多新的频率分量。 何谓相干接收？何谓非相干接收？ 答：在接收设备中利用载波相位信息去检测信号的方法称为相干检测和相干解调。反之，若 不利用载波相位的信息检测信号， 则称为非相干检测或非相干解调。 试问 2ASK 信号产生和解调的分别有几种方法？ 答：产生：相乘电路和开关电路解调：包络检波法和相干解调法 试问 2ASK 信号的带宽和其基带信号的带宽有什么关系？ 答：2 倍 试问 2FSK 信号属于线性调制还是非线性调制？ 答：2FSK 和 2PSK 为非线性调制 ２ASK 为线性调制 试问 2FSK 信号相邻码元的相位是否连续与其产生关系有何关系？ 答：调频器产生的 2FSK 信号相邻码元相位连续，开关法产生的 2FSK 信号相邻码元相位不连续。 试问 2FSK 信号的带宽和其基带信号的带宽有什么关系？ 答：2 倍 试问常用的 2FSK 信号解调方法是相干解调还是非相干解调？ 为什么？ 答：在信道特性不稳定的情况下，例如无线电信道，接收信号的相位在不断的变化，很难实 现相干接收，故 2FSK 信号的接收多采用包络检波法（非相干解调法） 试问 2PSK 信号相邻码元间的波形是否连续和什么因素有关？ 答：载波频率和码元速率之间的关系决定了 2PSK 信号相邻码元之间的波形是否连续。 试问 2PSK 信号是否必须用相干解调法接收？ 答：是 试问 2DPSK 信号相邻码元间的波形是否连续和什么因素有关？ 答：除了与 2PSK 类似的因素外，２DPSK 信号相邻码元波形是否连续还和基带信号跳变有关 2DPSK 信号有几种解调方法？ 答：相位比较法和相干解调法（极性比较法） 试问 2PSK 信号和 2ASK 信号之间有什么关系？ 答：2ASK 信号可以看成 0 信号与载波的叠加，而 2PSK 信号可以看成是抑制载波后的 2ASK 信号。 ** 试按误码率高低次序排列各种二进制键控和解调方式。 答：非相干 ASK ，相干 ASK ，非相干 FSK ，相干 FSK ，非相干 DPSK ，相干 DPSK ，PSK 。 第七章何谓载波同步？试问在什么情况下需要载波同步**?**答：本地载波和接收信号载波的同步问题称为载波同步。 本地载波的频率和相位信息必须来自接收信号，或者需要从接收信号中提取载波同步信息。 在接收数字信号的一个码元时，为了在判决时刻对码元的取值进行判决，接收机必须知道准确的判决时刻。 试问插入导频法载波同步有什么优缺点？答：插入导频法主要用于接收信号频谱中没有离散载频分量，且在载频附近频谱幅度很小的 情况，能在接收端解调时在输出中不产生新增的直流分量。不增加频谱资源，但需要消耗功 率资源。 试问哪类信号频谱中没有离散载频分量？答：无直流分量的基带信号经调制后就没有离散载频分量，如 SSB、 VSB、2PSK 等信号。 试问能否从没有离散载频分量的信号中提取出载频？若 能，试从物理概念上作解释。答：可以，将接受信号做非线性的处理，就有可能出现离散载频分量。 试问什么是相位模糊问题？在用什么方法提取载波时会 出现相位模糊？解决相位模糊对信号传输影响的主要途径 是什么？答：从接收信号提取出的载波，其相位差可能是 0，也可能是π，这种不确定性称为相位模糊问题。用平方法、科斯塔斯环法提取时。解决方法是插入导频法和差分信号法。 试问对载波同步的性能有哪些要求？答： 1、载波同步精确度。 2、同步建立时间和保持时间。 3、载波同步误差对误码率的影响。 何谓位同步？试问位同步分为几类？答：位同步即码元同步， 为了使每个码元得到最佳的调解， 以及在准确的判决时刻进行接收 码元的判决，必须知道码元准确的起止时刻。 分为两大类：外同步法， 它需要在信号中外加包含位定时信息的导频或数据序列。自同步法，它从信息码元序列本身中提取出位定时信息。 何谓位同步法？试问外同步法有何优缺点？答：外同步法又称为辅助信息同步法，它是在正常信息码元序列外附加位同步的辅助信息， 以达到提取位同步信息的目的。在接收端利用一个窄带滤波器，将其分离出来，并形成码元定时脉冲。这种方法的优点是设备简单，缺点是需要占用一定的频带宽带和发送功率。 何谓自同步法？试问自同步法又分为几种？答： 自同步法：是指接收方能从数据信号波形中提取同步信号的方法。两种：开环同步和闭环同步。 试问开环法位同步有何优缺点？答：可直接从信息码元序列中提取出定位信息，存在非 0 平均同步跟踪误差。 试问闭环同步法有何优缺点？答：同步性能好；长时间无跳变边沿会影响同步。 何谓群同步？试问群同步有几种方法？答：为了使接收到的码元能够被理解， 需要知道其是如何分组的，接收端需要群同步信息去划分接收码元序列。 两种： 一类方法是在发送端利用特殊的码元编码规则使码组本身自带分组信息。另一类是在发送端码元序列中插入用于群同步的若干特殊码元，称为群同步码。 何谓起止式同步？试问它有何优缺点？答：在每个码组之前加入一个”起码元”、滞后加入一个”止码元”，这种群同步方式称为 起止式同步，优点是实现简单，缺点是传输速率较低。 试比较集中插入法和分散插入法的优缺点。答：集中插入法的优点是同步建立快，缺点是同步保持时间短；分散插入法的优点是同步保 持时间长，缺点是同步建立慢。 试述巴克码的定义答：若有一个包含 N 个码元的码组，其自相关函数 R（0）=N，在其他处 R（j）的绝对值均不大于 1，则称其为巴克码。 试问为什么要用巴克码作为群同步码？答：因为巴克码优良的自相关特性。 试问群同步有哪些性能指标？答：要求的主要指标是假同步概率和漏同步概率。 何谓网同步？试问网同步有几种实现方法？答：网同步是指通信网的时钟同步，解决网中各站的载波同步、位同步和群同步等问题。 试比较开环法和闭环法网同步的优点和缺点。答：开环法的主要优点是捕捉快，不需要反向链路也能工作，实时运算量小。其缺点是需要 外部有关部门提供所需的链路参量数据，并且缺乏灵活性。闭环法的优点是不需要外部提供 有关链路参量数据，并且可以很容易地利用反向链路来及时适应路径和链路情况的变化。其缺点是终端站需要有较高的实时处理能力，并且每个终端站和中心站之间要有双向链路。"},{"title":"UDS诊断入门","path":"2022/01/09/UDS诊断入门/","text":"UDS（Unified Diagnostic Services，统一的诊断服务）诊断协议是在汽车电子ECU环境下的一种诊断通信协议，一旦零部件出了问题或者出过问题，它们会把故障信息保存在内存里面，维修师傅就可以通过通信总线读取这些故障信息，比如一个ECU经历欠压故障之后，它会将欠压故障代表的DTC（诊断故障码）存储起来，可选择性保存的还有发生故障时的快照信息（比如此时的车速、读到的电压值等）。 SID：Service Identifier，诊断服务ID。UDS本质上是一种定向的通信，是一种交互协议（Request/Response），即诊断方(Tester)给ECU发送指定的请求数据（Request），这条数据中需要包含SID，且SID处于该应用层数据的第一个字节。如果是肯定的响应（Positive Response），首字节回复**[SID+0x40]，举例子就是请求0x10，响应0x50；请求0x22，响应0x62。如果是否定的响应（Negative Response），首字节回复0x7F**，第二字节回复刚才询问的SID。比如Tester请求0x10服务，我想进入编程模式，ECU给出否定响应，首字节0x7F，第二字节回复0x10，代表我否定你的0x10服务请求，第三字节是NRC(否定响应码)，代表我否定你的依据。 常见的诊断服务 $10诊断会话 Diagnostic Session Control$10包含3个子功能，01 Default默认会话，02 Programming编程会话，03 Extended扩展会话，ECU上电时，进入的是默认会话（Default）。 为什么设计三个会话模式呢？因为权限问题。默认会话权限最小，可操作的服务少；扩展模式通常用于解锁高权限诊断服务，例如写入数据/参数、读写诊断码；编程模式用于解锁bootloader相关的诊断服务，即程序烧录。 题外话，讲个故事。这三个会话模式好比普通项目成员（默认会话）、项目组长（扩展会话）和会计（编程会话）的关系，小职员权限最小，小职员有的权限项目组长全有，项目组长还多了些其他的高端权限（如写数据、例程控制）。会计则不同，它有些自己独有的权限（刷写程序），但项目组的很多权限它没有（读/擦故障码），因为它只干会计相关的事，本身不参与项目。 如果您进入了一个非默认会话的状态，一个定时器会运转，如果一段时间内没有请求，那么到时间后，诊断退回到默认会话01(最低权限)。当然，我们有一个**$3E**的服务，可以使诊断保持在非默认的状态。 UDS的请求命令有4种构成方式，即SID，SID+SF（Sub-function），SID+DID（Data Identifier）（读写用），SID+SF+DID。每种服务都有自己不同的构成方式，查看服务说明即可，不用死记硬背。 NRC：Negative Response Code（否定响应码）。如果ECU拒绝了一个请求，做出否定响应（Negative Response），它会在第三字节回复一个NRC。不同的NRC有不同的含义。 这里提一下一个特殊的NRC——0x78，requestCorrectlyReceived-ResponsePending（RCRRP，请求已被正确接收-回复待定）。这个NRC表明请求消息被正确地接收，请求消息中的所有参数都是有效的，但是要执行的操作还没有完成，Server端还没有准备好接收另一个请求。一旦请求的服务已经完成，服务器应该发送一个积极的响应或消极的响应，响应代码应与此不同。这个NRC的消极响应可以被Server端重复，直到被请求的服务完成并且最终的响应消息被发送。 例子：以CAN总线网络举例。CAN帧一共8个字节，第一字节被网络层占用。(ISO 15765-2的知识) 进入01会话成功，进入02会话失败，进入03会话成功 请求（Request）:02 10 02 xx xx xx xx xx ; 02是网络层单帧SF，表示应用层包含有2个字节，10是服务ID(SID)，02是子功能——进入编程会话。但ECU婉拒了它的请求 肯定响应:02 50 02 xx xx xx xx xx；02即应用层含两个字节，50=10+40表示对SID的肯定回复，02是子功能。 否定响应:03 7F 10 7E xx xx xx xx；03同上，7F表示否定响应，10是SID，7E是NRC（否定响应码）。 $3E待机握手$3E服务用于向服务器指示诊断仪仍然连接在网络上，之前已经激活的诊断服务功能可以仍然保持激活状态。 例子：02 3E 80 00 00 00 00 00，发送一个3E服务的报文，保持非默认会话状态。80表示无需回复。 $27安全访问$27安全访问：ECU当中有很多数据是整车厂独有的，并不希望开放给所有客户，它需要做一个保密的设定。我们在读取一些特殊数据的时候，要先进行一个安全解锁。ECU上电之后是一个锁定的状态（Locked），我们通过**$27**服务，加上一个子服务，再加上一个钥匙，这样的服务请求可以进行解锁。 $27安全访问服务的否定响应服务ID也是7F。还记得刚才否定响应的格式吗？7F+27+NRC（否定响应码）。 实际通信的截图，黄色位置是密钥区域 例子： Tester： 02 27 05 00 00 00 00 00 安全访问，05子功能 ECU： 06 67 05 08 27 11 F0 00 肯定响应，回复了对应安全级别的种子 Tester： 06 27 06 FF FF FF FF 00 发送密钥，4个FF。注意06是与05成对使用的。 ECU： 03 7F 27 78 00 00 00 00 若为否定响应，7F+27+NRC ECU： 02 67 06 00 00 00 00 00 若为肯定响应，通过安全校验 $22读数据$22读数据，Request（请求）：22+DID（Data Identifier，通常是两个字节） Response（响应）：62+DID+Data $2E写数据$2E写数据，Request（请求）：2E+DID+Data Response（响应）：6E+DID 写入一个VIN码 正确的顺序是10开头的帧请求、30开头的帧回复、21开头再请求、22开头继续请求、03开头回复确认。我们一帧一帧来看。 10 14根据ISO15765-2代表这是一组多帧中的首帧（属于传输层的信息），一会要发0x14=20个字节的有效数据。之后是2E+F190（代表这是VIN码）+VIN码的前3个字节。意思是作为外部工具，想写入一个VIN码数据。这件事情正常是发生在车辆下线时。 30 00 0A是TP层（传输层）的信息，表示这是一个流控帧，ECU发出的，表示可以一直连续发，但连续帧最短的间隔时间要求是10ms。 21是TP层的信息，表示这是一个连续帧，序号为1。后面是VIN码的第4字节到第10字节。 22是TP层的信息，表示这是一个连续帧，序号为2。后面是VIN码的第11字节到第17字节。 03是TP层的信息，这里说的这个TP层的信息是传不到应用层的，即这是一个用完就会抛弃的信息。03的0表示这是一个单帧，3表示后面有3个有效字节。6E表示我们确认执行了2E服务的请求，这个请求写入的ID是F1 90，即VIN码。 注意，比如0xF190等DID不支持直接写入数据，需要用$10来进行会话转换。也就是说，对于写数据的请求，一般来说需要在一个扩展会话，和安全等级1的状态下才能进行。 $19 读DTC19服务是一套诊断服务中的重中之重。协议中篇幅长达63页，通信举例达到了18个。可以说没有19服务，就没有完整的UDS。 DTC（diagnostic trouble code）：如果系统检测到了一个错误，它将存储为DTC。DTC可表现为：一个显而易见的故障；通讯信号的丢失（不会使故障灯亮起）；排放相关的故障；安全相关的错误等。DTC可以揭示错误的位置和错误类型。通常DTC占用3个字节，OBD II占用两个字节。图中FTB为Fault Type Byte。 故障码包括四个大类，分别是PCBU，P是powertrain动力系统，C是Chassis底盘，B是Body车身，U是network通信系统。一个DTC信息占用4个字节。最后一个字节是DTC的状态。DTMMiddleByte和DTCLowByte两个字节是我们熟知的类似P0047（ISO15031中的故障码）中“0047”的纯数字故障码。第一个字节在乘用车中，前两个bit代表P/C/B/U（动力/底盘/车身/网络）中的一个，之后六个bit是数字，合在一起的样子形如“C01”。第一个字节的前2个bit中，用00/01/10/11分别表示P/C/B/U $19拥有28个子服务（Sub-Function）。常用的子服务有： 01 (读取符合掩码条件的DTC数量)（必须支持）,后面的参数是DTC状态掩码，若为01表示我想读当前故障，若为08表示我想读历史故障，若为09表示当前故障和历史故障都想读。 在肯定回复时，组合应该是59(19+40) - 01 （子功能） - 09 （本ECU所支持的掩码条件）-01 DTC的格式（ISO14229-1为01） - 00 01 （目前满足条件的DTC有一个） 02（读取符合掩码条件的DTC列表及其状态）（必须支持），后面的参数是DTC状态掩码，解读同上。 在肯定回复是，59 - 02（子功能）- 09（本ECU所支持的掩码条件） - XX XX XX ( DTC,车厂定义 ) - 01 （这个故障码怎么了，01表示当前故障） 04（读取快照信息），也叫冻结帧。 06（读取扩展信息）。 0A（读取ECU支持的所有DTC列表及其状态）（必须支持）。这个就不必发DTC状态掩码了。所有支持的DTC列表及其状态都会打印出来。 黄色框是DTC，紧跟着的是DTC状态 同时读取当前/历史故障，黄色框是DTC，紧跟着的是DTC状态 刚才提到，一个DTC除了它自己的3个字节，还有一个字节专门用于表达DTC的状态，这个字节我们叫它DTC状态掩码。这个状态字节每个位的含义下面列举出来。注意，在实际项目中，并不是所有的DTC状态都是支持的。DTC状态掩码前7个位的理解是UDS的一个难点。 $14清除DTC清除（复位）DTC格式，它可以改变DTC的状态。DTC状态中的八个位，除bit4和bit6外均会被清零，包含当前故障（TestFailed）和历史故障（ConfirmedDTC）。bit4和bit6这两个testNotCompleted开头的会被强制置1。 3个FF代表清除所有DTC。 Request：14+FF+FF+FF； Response：54 。 14服务 $2F IO控制该服务可以通过DID(数据标识符)来进行输入信号的替换和控制零部件负载输出。这是一个用在产线上较多的服务。该报文的请求至少由4个字节组成。第一个字节是2F，第二第三字节是DID，其中第二字节是高位。第四字节是子功能，IO控制类型。 IO控制类型分为4类， 00是控制权还给ECU，Return Control To ECU。 01是复位为默认值，Reset to Default。 02是冻结当前的状态，Freeze Current State。 03是短暂接管控制权，Short Term Adjustment。 若控制类型是00-02这三种，请求报文是4个字节。 若控制类型是03，请求报文的第五字节是控制代码，可以是数字量，比如01是开，00是关；也可以是模拟量，比如空调风门的开度。 2F服务，黄色区域为2个字节的DID 上面这个图可以理解为，关闭开关，之后打开开关，之后控制权还给ECU，之后想复位回默认值，但是发现ECU不支持。这里NRC用0x22是否准确，还望大神告知。 2F服务有一个问题，如果通过2F服务修改了某个值，后续也不把控制权还给ECU，那么这个修改的有效时间是一直持续下去？ 正确的做法是如果扩展会话超时，即切回默认会话，此时控制权应还给ECU，毕竟 2F的03子功能是”暂时接管控制权”。 6种模式的配置非默认会话在实际中又细分为编程会话（Programming Diagnostic Session）和扩展会话（Extended）。在UDS的实际应用中，我们需要对26种服务针对不同会话、不同寻址模式的支持度进行配置。 也就是说，物理寻址+默认会话、物理寻址+编程会话、物理寻址+扩展会话、功能寻址+默认会话、功能寻址+编程会话、功能寻址+扩展会话，共6个模式。那么我们可以脑补一个26行、6列的表格了。 举个例子，对于10、11、3E、22（22有分歧）服务，它们需要支持所有的6个模式（物理+功能寻址）。 对于14、19服务，DTC相关，要求支持默认+扩展会话的4个模式（物理+功能寻址）。 对于27服务，即安全访问服务，仅支持扩展+物理、编程+物理2个模式。 对于2E、2F服务，仅支持扩展+物理1个模式，且要求安全等级为1。 对于34、36、37服务，涉及程序下载，仅支持编程+物理1个模式，且要求安全等级为2。 对于28、85服务，有些要求支持编程+扩展会话的4个模式，有些则要求仅支持扩展会话的2个模式。 对于31服务，要求安全等级为1，有些要求支持扩展+物理、编程+物理2个模式，有些则要求仅支持扩展+物理1种模式。 注：本文引用https://zhuanlan.zhihu.com/p/37310388"},{"title":"考研初试开销","path":"2022/01/08/考研初试花销/","text":"今晚无聊想算算考个研究生初试要花多少钱 李永乐复习全书——————20 英语黄皮书——17 李永乐660题——19.5 李林880——18 朱伟单词本——12.8 百乐水笔——20+16.4+18.4+26.5 草稿本加笔记本——29.07+8.27+8.6+8.6+33.6+66 专业课闫石数电第六版——42 李永乐330——12.35 考研真相——48 字帖——8.9+19.8 肖1000——11 徐涛核心考案——11.6 张宇真题全解——14 腿姐背诵手册——11 汤家凤真题——15.8 李林六套卷——8.5 李永乐六套卷——23.8 肖八加肖四——17.8 李林四套卷——8 咸鱼买专业课真题—20+30 打印费——50以内吧 考研住酒店（两个人合住）——343.5 交通费（只计算考研回学校的，因为去考研的地方学校包车了）——52.5 报名费——161 百度云会员——6+6+5 根据不完全非官方统计大概是1219.3 （当然吃饭那些肯定是自己平时要吃的，所以不计入其中）"}]